ANSP-M-007
------------------------------------------------------------
http://10.50.23.214:8000/ <-- ctfd server
------------------------------------------------------------
duckduckgo <-- input ip address and cidr
------------------------------------------------------------
Layer---PDU---Name
7 Data      Application
6 Data      Presentation
5 Data      Session
4 Segments  Transport
3 Packets   Network (logical)
2 Frames    Data Link (physical) 
1 Bits      Physical
------------------------------------------------------------
#DAY 1#    will need to score 193/275 points to achieve a 70%.
------------------------------------------------------------
Networking standards play a crucial role in the realm of information technology, acting as the foundational framework that enables diverse devices and systems to communicate effectively within a network
------------------------------------------------------------
Application Layer: provides a network interface to the software applications that communicate over the network.
    It supports communication services directly to end-users or applications and provides network services such as file transfers,email, and remote login.
     -Remote Login: SSH (Secure Shell) and Telnet
    -Web: HTTP (Hypertext Transfer Protocol) and HTTPs
     -File Transfer: FTP (File Transfer Protocol), SFTP (SSH FTP), and FTPS (FTP Secure)
    -Email: SMTP (Simple Mail Transfer Protocol), POP (Post Office Protocol), and IMAP (Internet Message Access Protocol)
------------------------------------------------------------
Presentation Layer: deals with the syntax and semantics of the information exchanged between systems. 
  It translates data between the application layer and the lower layers, ensuring that the data is in a readable format.
  Tasks include data compression, encryption, and character set conversions.
  There are no protocols that operate at this layer. This layer deal more with encoding and file formatting.
 -Character encodings
 -Character encodings
 -Compression
 -Encryption
------------------------------------------------------------
Session Layer: establishes, manages, and terminates communication sessions between applications. It controls dialogues (full-duplex or half-duplex), maintains synchronization, and manages data exchange between applications.
  Sometimes the protocols that operate at this layer act as a "shim protocol" between various communicating devices.
    Protocols that operate at this layer:
        NetBIOS (Network Basic Input/Output System)
        RPC (Remote Procedure Call)
        PPTP (Point-to-Point Tunneling Protocol)
        SMB (Server Message Block) can operate like a "shim protocol" between various communicating devices.
        SOCKS (Socket Secure)
------------------------------------------------------------
Transport Layer: ensures end-to-end communication, providing error detection, error correction, and flow control. It breaks down larger messages into smaller segments, sends them across the network, and reassembles them at the destination.
    Protocols that operate at this layer:
        -Transmission Control Protocol (TCP): TCP is a connection-oriented protocol that provides reliable and ordered delivery of data packets.
        It establishes a virtual connection between the sender and receiver, manages packet acknowledgment, retransmission, and flow control to ensure data integrity and delivery.
        TCP is widely used for applications that require error-free data transmission, such as web browsing, email, and file transfer.
        -User Datagram Protocol (UDP): UDP is a connectionless protocol that provides fast, but unreliable, delivery of data packets.
        Unlike TCP, UDP does not establish a connection or guarantee packet delivery, making it faster but less reliable.
        It is commonly used for real-time communication applications like video streaming, online gaming, and Voice over IP (VoIP), where occasional packet loss is acceptable.
------------------------------------------------------------
Network Layer: is responsible for logical addressing, routing, and forwarding. It enables devices to communicate across different networks by determining the best path for data to travel from the source to the destination. 
IP (Internet Protocol) and IPv6 operates at this layer.
    Protocols that operate at this layer:
        -Internet Protocol version 4 (IPv4): IPv4 is the most widely used version of the Internet Protocol.
        It uses 32-bit addresses, allowing for approximately 4.3 billion unique addresses. However, due to the exhaustion of available IPv4 addresses, IPv6 has been developed as its successor.
        -Internet Protocol version 6 (IPv6): IPv6 is designed to address the limitations of IPv4 by using a 128-bit address space, providing a vastly larger number of possible addresses.
        It offers improved security, better support for mobile devices, and more efficient routing compared to IPv4.
        -Internet Control Message Protocol (ICMP): ICMP is used for network diagnostics and error reporting.
        It allows routers and hosts to communicate error messages, such as "destination unreachable" or "time exceeded," back to the source host.
        -Internet Group Management Protocol (IGMP): IGMP is used by IPv4 systems to manage multicast group membership.
        It enables hosts to inform routers about their desire to receive multicast traffic for specific multicast groups.
        -Neighbor Discovery Protocol (NDP): NDP is used in IPv6 networks for address resolution, router discovery, and neighbor detection.
        It replaces Address Resolution Protocol (ARP) in IPv4 networks.
        -Open Shortest Path First (OSPF): OSPF is an interior gateway routing protocol used within autonomous systems.
        It employs the shortest path first (SPF) algorithm to calculate the best route between routers, considering factors such as link cost and network congestion.
        -Routing Information Protocol (RIP): RIP is another interior gateway routing protocol used within autonomous systems.
        It uses the distance-vector routing algorithm and is simpler to configure compared to OSPF, although it may be less efficient in larger networks.
------------------------------------------------------------
Data-Link Layer: is responsible for creating a reliable link between two directly connected nodes. It handles issues such as framing, addressing, and error detection. It also manages access to the physical medium and controls how data is placed on the medium.
    Protocols that operate at this layer:
        -Ethernet: Ethernet is the most widely used data link layer protocol.
        It defines standards for the physical and data link layers, including how data is framed for transmission over Ethernet networks and how devices on the same network share the communication medium.
        Ethernet uses MAC (Media Access Control) addresses to identify devices on the network. 
        -IEEE 802.11 (Wi-Fi): The IEEE 802.11 standard governs wireless local area network (WLAN) technologies, commonly known as Wi-Fi.
        It defines how wireless devices communicate with each other over radio frequencies, including protocols for data framing, channel access, and security.
        -Ethernet VLAN Tagging (IEEE 802.1Q): IEEE 802.1Q is a protocol used to implement virtual LANs (VLANs) on Ethernet networks.
        It adds a VLAN tag to Ethernet frames, allowing devices to distinguish between different VLANs and route traffic accordingly.
        -Address Resolution Protocol (ARP): ARP is used to map IP addresses to MAC addresses on a local network.
        When a device needs to communicate with another device on the same network, it sends an ARP request to discover the MAC address associated with the IP address.
        -Reverse Address Resolution Protocol (RARP): RARP performs the opposite function of ARP.
        It maps MAC addresses to IP addresses, typically used by diskless workstations to obtain their IP addresses from a server based on their MAC addresses.
        -Link Layer Discovery Protocol (LLDP): LLDP is a vendor-neutral protocol used to discover information about neighboring devices on a network.
        It allows network devices to exchange information about their identity, capabilities, and status.
        -Cisco Discovery Protocol (CDP): Similar to LLDP, CDP is a proprietary protocol developed by Cisco.
        It enables Cisco devices to discover and share information about neighboring Cisco devices on a network, including device type, IP address, and software version.
------------------------------------------------------------
Physical Layer: deals with the physical connection between devices. It defines the hardware elements, such as cables, connectors, and the transmission medium (e.g., copper wires, fiber optics). 
It is concerned with the raw transmission of bits over a physical medium. The protocols define the electrical, mechanical, and functional specifications for transmitting raw bit streams over physical mediums.
    Protocols that operate at this layer:
        -Ethernet Physical Layer Standards (IEEE 802.3): IEEE 802.3 standards define the physical and electrical characteristics of Ethernet networks. 
        They specify parameters such as cable types (e.g., twisted pair, fiber optic), signaling methods (e.g., Manchester encoding, 4B5B encoding), and data transmission rates (e.g., 10 Mbps, 100 Mbps, 1 Gbps, 10 Gbps).
        -IEEE 802.11 (Wi-Fi): Wi-Fi is a family of wireless networking standards for local area networks (LANs).
        It defines physical layer specifications for radio frequency transmission over the air, including modulation techniques, channel widths, and data rates used in Wi-Fi networks.
        -Bluetooth: Bluetooth is a wireless technology standard for short-range communication between devices. 
        It defines physical layer specifications for radio frequency transmission, including frequency bands, modulation techniques, and power levels used in Bluetooth devices.
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------
        OSI Layer 1
------------------------------------------------------------
Base64 - usually has an = at the end
https://net.cybbh.io/public/networking/latest/01_data/_images/base64table.png
------------------------------------------------------------
TOPOLOGIES
-Bus
A bus network is a network topology in which nodes are directly connected to a common half-duplex link called a bus.
-Ring
A ring network is a network topology in which each node connects to exactly two other nodes, forming a single continuous pathway for signals through each node – a ring. Data travels from node to node, with each node along the way handling every packet.
-Mesh
  A mesh network is a local network topology in which the infrastructure nodes (i.e. bridges, switches, and other infrastructure devices) connect directly,
  dynamically and non-hierarchically to as many other nodes as possible and cooperate with one another to efficiently route data from/to clients.
  This lack of dependency on one node allows for every node to participate in the relay of information. Mesh networks dynamically self-organize and self-configure, which can reduce installation overhead.
  The ability to self-configure enables dynamic distribution of workloads, particularly in the event a few nodes should fail. This in turn contributes to fault-tolerance and reduced maintenance costs.
-Wireless
 A wireless network is a computer network that uses wireless data connections between network nodes. Note: All wireless connections eventually connect to a wired network.
-Hierarchial
    The hierarchical topology model is made up of the following:
        A core layer of high-end switches optimized for network availability and performance.
        A distribution layer of switches implementing forwarding decisions.
        An access layer connecting users via hubs, bridges, or switches.
------------------------------------------------------------
DEVICES
-Hubs are devices that allow multiple nodes to connect on the same wire (Collision Domain). https://en.wikipedia.org/wiki/Ethernet_hub
-Switches are devices that allow multiple nodes to connect on the network, but on their own collision domain.
    The layer 2 originating MAC address of the frame are learned from the incoming frames and are stored in the mac address table memory, also called a Content Addressable Memory (CAM) table.
-Repeaters are devices that allow a connection to be extended beyond the normal operational cable or wireless limits.
-Routers, Backbone of the internet. have Routing tables for ipv4 and ipv6 and how to get to them
------------------------------------------------------------
 Ethernet Timing
Speed 	Bit-time
10 Mbps    100ns
100 Mbps   10ns
1 Gbps     1ns
10 Gbps   .1ns
100 Gbps .01ns
------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
OSI Layer 2
Media Access Control (MAC):
    The MAC sub-layer is responsible for controlling access to the physical transmission medium.
    Handles the transmission and reception of data frames over the physical medium, including addressing, framing, and error checking.
    Act as a sublayer governing protocol access to the physical medium, physical addressing, and acts as an interface between the LLC and physical layer. Most of the frame construction happens at this layer.
        Provides the destination MAC address.
            Either a broadcast (FF:FF:FF:FF:FF:FF) to address all nodes on LAN.
            Unicast MAC (4A:30:10:19:10:1A) to address one node on LAN.
            Multicast MAC (01:00:5E:00:00:C8) to address a group of nodes on a LAN. Will have a Multicast address as the destination IP.
        Provides the source MAC address, forwards based on destination.
            Always a Unicast MAC.
        Calculates the Cyclic Redundancy Check (CRC) on the Frame and appends to the Frame Check Sequence (FCS) field.
        Controls access to/from the medium.
            Sending bit-rate (bit speed)
            Duplex (Half or Full) and CSMA/CD functions
            Frame delimiting and recognition
Logical Link Control (LLC):
    The LLC sub-layer is responsible for establishing, maintaining, and terminating logical links between network devices.
    Provides services such as error detection and flow control to ensure reliable data transmission over the physical medium.
    LLC defines the framing and addressing mechanism for data frames and handles the multiplexing of network layer protocols.
    It acts as an interface between the Network Layer (Layer 3) and the MAC sub-layer, enabling communication between the two layers regardless of the underlying physical media.
    Manages communication between devices over a single link of the network that includes error checking and data flow.
    Multiplexes protocols to be sent over the MAC sub-layer.
    Follows the IEEE 802.2 standard.
    This layer provides the Ethertype to the MAC sublayer in the frame construction to identify the encapsulated protocol.
        0x0800 for IPv4
        0x0806 for ARP
        0x86dd for IPv6
        0x8100 for 802.1q VLAN tag
------------------------------------------------------------------------------------------------------------------------
    Switch Operation: A switch allows multiple users to access the network and can provide segmentation to isolate traffic flow and reduce collisions, relieving network congestion in most cases.
    All switches add small latency delays due to packet processing.
    These delays could be caused by port speed, frame processing (Cut-through or Store and Forward), port delay, and buffering delay. Deploying switches unnecessarily can actually slow down network performance.

    -Store-and-Forward accepts and analyzes the entire frame before forwarding it to its destination.
      It takes more time to examine the entire frame, but it allows the switch to catch certain frame errors and collisions and keep them from propagating bad frames through the network. This method is required to switch frames between links of different speeds; this is due to bit-timing.
      The speed at which the bits enter one interface may be slower than the speed at which the switch needs to send the bits to a different interface.
!!  -Cut-Through (sometimes called fast forward) only examines the destination address before forwarding it to its destination segment. This is the fastest switching mode but requires the interfaces to be the same speed.
    -Fragment-Free read at least 64 bytes of the Ethernet frame before switching it to avoid forwarding Ethernet runt frames (Ethernet frames smaller than 64 bytes).
      A frame should have a minimum of 46 bytes of payload plus its 18-byte frame header.
------------------------------------------------------------------------------------------------------------------------
CAM Table Overflow/Media Access Control (MAC) Attack
 This attack aims to overwhelm a switch’s CAM table, which is used to store MAC address-to-port mappings, leading to a denial of service (DoS) condition or facilitating a man-in-the-middle attack.
 This attack focuses on the Content Addressable Memory (CAM) table that stores the MAC addresses on a switch. A switch with only one VLAN will just have one CAM table. A switch will create a serarate CAM table for each VLAN supported by the switch.
------------------------------------------------------------------------------------------------------------------------
Describe MAC addressing
Length:
    48 bits or 6 bytes in length represented by 12 hexadecimal digits.
Different Formatting:
    Windows: 01-23-45-12-34-56
    Unix/Linux: 01:23:45:12:34:56
    Cisco: 1234.5612.3456

Organizationally Unique Identifier (OUI) - First 24 bits or 3 bytes or 6 HEX.
    The OUI is typically assigned by IANA to a vendor, manufacturer, or other organization.
Vendor assigned - Last 24 bits or 3 bytes or 6 HEX.

Unicast: one-one
Multicast: one-many
broadcast: to everyone
------------------------------------------------------------------------------------------------------------------------
Type II Frame
Destination MAC, Source MAC, EtherType
0x0800--IPv4
0x0806--ARP
0x86DD--IPv6
------------------------------------------------------------------------------------------------------------------------
VLAN TYPES
Default- VLAN 1
Data- User Traffic
VOice- VOIP Traffic
Management- switch and router management
Native- Untagged switch and router Traffic
------------------------------------------------------------------------------------------------------------------------
ARP
Operation Specifies the operation that the sender is performing:
    1 = ARP request
    2 = ARP reply
    3 = RARP request
    4 = RARP reply
------------------------------------------------------------------------------------------------------------------------
    -ARP - A request and response in order to resolve the destination L2 (MAC) address when only the destination L3 (IPv4) address is known.
        ARP Request Operation code = 1
        ARP Reply Operation code = 2
        ARP Request:
            When a device needs to communicate with another device on the same network segment but only knows the destination’s IP address, it broadcasts an ARP request message to the entire network.
            The ARP request contains the sender’s IP address and MAC address and the IP address of the target device.
        ARP Reply:
            The device with the IP address specified in the ARP request responds with an ARP reply.
            The ARP reply contains the target device’s MAC address.
            Once the sender receives the ARP reply, it can use the MAC address to address frames destined for the target device.
    -RARP - A request and response in order to resolve the destination L3 (IPv4) address when only the destination L2 (MAC) is known. (This protocol has been deprecated since the widespread use of protocols like BOOTP and DHCP.)
        RARP Request Operation code = 3
        RARP Reply Operation code = 4
        When a device boots up and has no configured IP address, it broadcasts a RARP request onto the local network.
        The RARP request contains the device’s MAC address.
        RARP servers on the network receive the broadcast request and check their tables for a corresponding IP address entry associated with the MAC address.
    -Gratuitous ARP - An ARP reply that was not requested
        ARP Reply Operation code = 2
        A gratuitous ARP messages is an ARP messages sent by a device to announce its own IP-to-MAC address mapping to other devices on the network.
        Gratuitous ARP messages are commonly used during network initialization or to update ARP caches in other devices.
        These are commonly used for:
            Help in detecting IP conflicts
            Assist in updating other system’s ARP cache
            To inform switches of the MAC address of the client connected to its port
            Helps pre-load other systems ARP cache when the local systems IP interface comes up
        Maliciously used to:
            Poision a victim’s ARP cache
    -Proxy ARP - A device (router) answers the ARP queries for IP address that is on a different network.
        The ARP proxy sees the ARP request and determines that the target Network address is not on the local network segment and is aware of how to reach the destination network.
        The proxy will offer its own MAC address in response to the request.
        Typically this device is the network gateway and is responsible to forward traffic for other networks.
        Maliciously the ARP requests can be intercepted and a Proxy ARP sent as a response to poision the victim’s ARP Cache.
    -ARP Cache - is a collection of Layer 2 to Layer 3 address mappings discovered utilizing the ARP request/response process. When a host needs to send a packet both the L2 and L3 addresses are needed.
        The host will look in this table to determine if it already knows both the L2 and L3 addresses. If the target is not in the table then a ARP request is initiated.
        The ARP cache can be populated statically but mostly its done dynamically. This cache can be exploited by attackers with the aim to poison the cache with incorrect information to either perform a DoS or MitM.
    Command:
      arp -a
      ip neighbor
------------------------------------------------------------------------------------------------------------------------
VLAN TRUNKING PROTOCOL(VTP)
    Key Concepts of VTP
        1. VTP Domain
            Definition: A VTP domain is a group of switches that share the same VTP configuration and VLAN information. All switches in the same VTP domain share VLAN information and synchronize their VLAN databases.
            Configuration: Each switch must be configured with the same VTP domain name to participate in the same VTP domain.
        2. VTP Modes
            Server Mode:
                Description: Switches in VTP Server mode can create, modify, and delete VLANs and share these VLAN configurations with other switches in the VTP domain. They also maintain a VLAN database that is synchronized with other switches.
                Default Mode: Switches are in VTP Server mode by default.
            Client Mode:
                Description: Switches in VTP Client mode receive VLAN information from VTP Servers and apply these VLAN configurations, but they cannot create, modify, or delete VLANs. They rely on VTP Servers for their VLAN information.
            Transparent Mode:
                Description: Switches in VTP Transparent mode do not participate in VTP VLAN information exchange. They forward VTP advertisements but do not apply them or update their VLAN database based on VTP information.
                They maintain their own VLAN configurations and do not propagate changes to other switches.
            Off Mode:
                Description: In some contexts, "Off" mode may be used to disable VTP entirely on a switch. This mode is not a standard VTP mode but can be used to refer to a state where VTP is not active.
        3. VTP Advertisements
            Types:
                Summary Advertisements: Contain information about the VTP domain name, revision number, and VLAN information.
                Subset Advertisements: Carry VLAN configuration changes.
                Advertisement Requests: Request VTP advertisements from other switches.
            Purpose: Advertisements are used to propagate VLAN changes and maintain consistency across the VTP domain.
        4. VTP Revision Number
            Description: Each VTP advertisement includes a revision number that is incremented with each change to the VLAN configuration. Higher revision numbers indicate more recent configurations.
            Switches use the revision number to determine if they should update their VLAN database based on received advertisements.
There are three versions of VTP, version 1, version 2, version 3.
------------------------------------------------------------------------------------------------------------------------
DYNAMIC TRUNKING PROTOCOL(DTP)
 On by default
 can send crafted messages to form a vlan trunk link
 Recommended to:
   disable DTP negotiations
    <switchport nonegotiate>
   Maunually assign as Access or Trunk
    <switchport mode access> or <switchport mode trunk>
------------------------------------------------------------------------------------------------------------------------
    -Cisco Discovery Protocol (CDP) is a Layer 2, Cisco proprietary protocol used to share information with other directly connected Cisco devices. CDP is protocol and media independent and runs on all Cisco routers, switches, and other devices.
        CDP Shares information such as:
            Device ID (hostname)
            IP address
            Port ID (interface on the device)
            Platform (device model)
            Capabilities (e.g., router, switch)
            Number and type of interface
            IOS software version
          CDP can be used as a Network Discovery tool as well as assist in network design decisions and troubleshooting.        
Mitigation of CDP ATTACK
    Disable Globally with <no cdp run>
    Disable on an interface with <no cdp enable>

    -Foundry Discovery Protocol (FDP) is a proprietary data link layer protocol, originally developed by Foundry Networks, which was bought by Brocade. 
        Similar to CDP, FDP enables Brocade devices to advertise to other directly connect Brocade devices on the network.
    -Link Layer Discovery Protocol (LLDP) was designed by IEEE 802.1AB to be a vendor-neutral neighbor discovery protocol similar to CDP.
        LLDP also operates at layer 2 and shares similar information as does CDP with directly connected devices that support LLDP.
------------------------------------------------------------------------------------------------------------------------
SPANNING TREE PROTOCOL(STP)
   Stops circulating frames
      -Elect the Root Bridge
      -Identify the Root port on each non-root bridge
      -Identify the Designated port for each segment

------------------------------------------------------------------------------------------------------------------------
Port Security
The purpose of configuring port security technologies is to limit, restrict, and protect network access. Configuring port security can be done on active access ports to limit the number of users or MAC addresses allowed to access onto the network.
This will help to alleviate attacks such as DoS, MAC Address Flooding, and most unauthorized access.
    MAC Address Limit:
        Port security allows administrators to specify the maximum number of MAC addresses allowed on a switch port.
        When enabled, the switch monitors the MAC addresses of devices connected to the port and takes action if the number of MAC addresses exceeds the configured limit.
    MAC Address Learning:
        When a device sends traffic through a switch port, the switch learns the device’s MAC address and associates it with the port.
        The switch maintains a table, known as the MAC address table or CAM table, which maps MAC addresses to switch ports.
    Violation Actions:
        Administrators can define violation actions to be taken when port security violations occur.
        Common violation actions include shutting down the port, sending an SNMP trap, or logging a message.
        These actions help alert administrators to potential security breaches and mitigate unauthorized access attempts.
        The following are the possible modes:
            protect - Drops any frames with an unknown source addresses.
            restrict - Same as protect except it additionally creates a violation counter report.
            shutdown - Places the interface into an "error-disabled" state immediately and sends an SNMP trap notification. This is typically the default mode.
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------
DAY 2


Layer 3 ROUTING
Network Layer
Internetworking was developed because Local Area Networks (LAN) needed the ability to communicate with one another.
    Addressing Schemes for Network (Logical Addressing)
        Each device on the network has a logical addresses associated with it. This address is independent of the hardware device and must be unique in an internetwork.
    Routing
        the moving of data across a series of interconnected networks is the job of devices and software that exist at this layer. The network layer must handle incoming packets from various sources,
        determine their final destination, and send them to the appropriate interface and forwarding devices to be processed and routed once again.
    Encapsulation
        Encapsulation of messages received from higher layers must be performed to be passed on to the data-link layer.
    IP Fragmentation and Reassembly
        Due to constraints on bandwidth and other limiting factors, the network layer must be able to fragment packets that are too large and re-assemble the data in order at the destination device.
    Error Handling and Diagnostics
        The network layer uses special helper protocols like ICMP and ARP that allow logically connected devices to exchange information about the status of the network or devices themselves.

IPv4
RFC 1918 Private addresses:
    RFC 1918 defines three blocks of IPv4 address space reserved for private use:
        10.0.0.0/8 (10.0.0.0 - 10.255.255.255)
        172.16.0.0/12 (172.16.0.0 - 172.31.255.255)
        192.168.0.0/16 (192.168.0.0 - 192.168.255.255)

class
A 0-217    /8
B 128-191  /16
C 192-223  /24
D 224-239
E 240-255
------------------------------------------------------------------------------------------------------------------------
Unicast A-C
Multicast D
Broadcast Any where host portion is all on
------------------------------------------------------------------------------------------------------------------------
IPv4 Address Scope
-Public
-Private(RFC 1918)
-Loopback(127.0.0.0/8)
-Link-local((APIPA)169.254.0.0/16) 
-Multicast(ckass d)
------------------------------------------------------------------------------------------------------------------------
More fragment 0 offset = first packet
more fragment offset = still a packet
no fragment offset = last packet
------------------------------------------------------------------------------------------------------------------------
os fingerprinting with ttl
    Linux: TTL from 34-64
    Windows: TTL from 98-128
    Cisco: TTL from 225-255
------------------------------------------------------------------------------------------------------------------------
DHCP
-DORA process
Discover, Offer, Request, Acknowledge
------------------------------------------------------------------------------------------------------------------------
ICMP
Echo Request( type 8)
Echo Reply( type 0)
Destination Unreachable(type 3)
Redirect(type 5)
Time Exceeded( type 11)
------------------------------------------------------------------------------------------------------------------------
ICMPv4 TRACEROUTE
-ICMP( WINDOWS DEFAULT)
-UDP(LINUX DEFAULT)
-TCP
_______________________________________________________________________________________________________________________

https://net.cybbh.io/public/networking/latest/02_network/_images/IPv6_Header.png
    IPv6 address types
        Unicast Addresses IPs are a "one to one" communication between two nodes.
            These are similar in function to that of IPv4 unicast addresses.
        Multicast Addresses Used for one to many communications and routing protocols.
            These perform the same function as the Class D or multicast addresses of IPv4.
            Range ff00::/8 - ff00:: thru ffff::
        Anycast Addresses These addresses can fall within the Global, Unique-Local, or Link-Local address scopes. 
They differ from unicast in that more than one device can be configured with the same address. These are typically used to address several network gateways. Each gateway can be configured with the same anycast address.
Any of these devices can supply the service request for the client.
These can also be used for servers when trying to load balance a particular service.
            Anycast addresses are assigned to a group of interfaces, but packets are routed to the nearest interface in the group based on routing metrics.
They are not specifically defined by a separate address block but use the global unicast address space.

    IPv6 address scope:
        Unspecified address is used to indicate the absence of an address.
            ::/128
        Loopback Address IPv6 address used by a node on a vitural interface to send packets to itself. This is the same as the 127.0.0.1 is for IPv4.
            ::1/128
        Global Unicast Addresses IPv6 addressess that are routable over the Internet.
            Scope is 2000::/3 - 2000:: thru 3fff:
                2001:0000:/32 - reserved for Teredo tunneling
                2001:20::/28 - reserved for ORCHIDv2
                2002::/16 - reserved for 6to4 tunneling
        Unique-Local Addresses (ULAs) IPv6 addresses the are routable locally within a site, not globally routable across the Internet. These perform a similar function as the RFC 1918 private IPv4 addresses and will require NAT to translate the address to a Global Unicast address for communication over the Internet.
            Scope is fc00::/7 - fc00:: thru fdff::
        Multicast addresses
            Scope ff00::/8 - ff00:: thru ffff::
                ffx0::/8 - reserved
                ffx1::/8 - interface-local - spans only a single interface on a host. Used for loopback multicast.
                ffx2::/8 - link-local - spans the local network. Does not traverse network bounderies. Comparable to 224.0.0.0/24 for IPv4.
                ffx3::/8 - realm-local - spans farther than link-local but under determination of the administrator. Should not bound farther than those below.
                ffx4::/8 - admin-local - smallest scope that can be administratively configured.
                ffx5::/8 - site-local - spans a single site of an organization.
                ffx8::/8 - organization-local - spans to all sites in a single organization.
                ffxe::/8 - global - spans all hosts on the internet and is unbounded.
                ffxf::/8 - reserved
        Link-Local Addresses IPv6 addresses that are assigned to a IPv6 enabled interface for direct link on link communcation
_______________________________________________________________________________________________________________________
Stateless Address Autoconfiguration (SLAAC) (default):
    SLAAC is the primary method of IPv6 address autoconfiguration and is similar to IPv4 DHCP in some respects but simpler.
    In SLAAC, routers on the local network periodically multicast Router Advertisement (RA) messages (FF02::1) to announce their presence and provide network configuration information.
    Hosts on the network receive these RA messages and use the information contained within them to configure their IPv6 addresses and other parameters.
    Hosts can also send Router Solicitation (RS) message (FF02::2) to request network information. This is commonly done when a host first powers on. The router will respond with a RA message to the host sent using FF02::1.
    Each host uses its unique identifier (based on the MAC address or another mechanism) and the network prefix advertised in the RA messages to generate its IPv6 address.
Stateful/Stateless Address Autoconfiguration (DHCPv6):
    DHCPv6 is an extension of the DHCP protocol used in IPv4 networks, and it provides additional configuration options beyond basic address assignment.
    With DHCPv6, hosts can obtain IPv6 addresses, DNS server information, and other network configuration parameters from a DHCPv6 server.
    DHCPv6 can be used in conjunction with SLAAC, allowing hosts to obtain additional configuration options from DHCPv6 while still using SLAAC for address assignment.
_______________________________________________________________________________________________________________________
 Explain Neighbor Discovery Protocol (NDP)
IPv6 nodes use NDP to discover other nodes on the local link. This is to determine other node’s link-layer addresses to find routers, and to maintain reachability information about the paths to active neighbor nodes.
NDP is vulnerable to various attacks if not secured.
NDP defines five ICMPv6 packet types for the purpose of router solicitation, router advertisement, neighbor solicitation, neighbor advertisement, and network redirects.
    Router Solicitation (Type 133)
        Hosts inquire with Router Solicitation messages to locate routers on an attached link. Routers which forward packets not addressed to them generate Router Advertisements immediately upon receipt of this message 
        rather than at their next scheduled time.
        Sent using the multicast address of FF02::2 (all routers) group.
    Router Advertisement (Type 134)
        Routers advertise their presence together with various link and Internet parameters either periodically, or in response to a Router Solicitation message.
        Sent using the multicast of FF02::1 (all nodes) group.
    Neighbor Solicitation (Type 135)
        Neighbor solicitations are used by nodes to determine the link layer address of a neighbor, or to verify that a neighbor is still reachable via a cached link layer address.
        Similar to an ARP Request when using IPv4. IPv6 does not use ARP however. It uses Neighbor Solicitation to request the MAC address of the destination.
        Duplicate Address Detection (DAD). Sent by host to the IPv6 address it intends to use. This is to determine if the address is already in use.
    Neighbor Advertisement (Type 136)
        Neighbor advertisements are used by nodes to respond to a Neighbor Solicitation message.
        Similar to an ARP Reply when using IPv4. IPv6 does not use ARP however. It uses Neighbor Advertisement to respond to a Neighbor Solicitation.
    Redirect (Type 137)
        Routers may inform hosts of a better first hop router for a destination.
_______________________________________________________________________________________________________________________


    Ultimate route is any routing table entry that has a next-hop IPv4 address, exit interface, or both.
    Level 1 route is any route with the subnet mask (CIDR) is equal to or less than the classful mask of the network address. A level 1 route can be a:
        Network route - A network route that has a subnet mask equal to that of the classful mask.
            Class A - 255.0.0.0 (/8)
            Class B - 255.255.0.0 (/16)
            Class C - 255.255.255.0 (/24)
        Supernet route - A network route with a mask less (smaller) than the classful mask.
            192.168.0.0/16
            These can be a range of IP addresses aggregated into a single, larger network address.
            Commonly used as network summary routes.
        Default route - A default route is a static route with the address 0.0.0.0/0 or ::.
    Parent route is a level 1 network that is subnetted. A parent roue will never be an ultimate route.
    Level 2 child route are the subnets of a classful network address.
    The primary functions of a router are to:
        Determine the best path to send packets.
            Builds and maintains routing tables to make this determination.
            Uses directly connected networks, static routes, and dynamic routing protocols to assist in building and maintaining this routing table.
        Forward packets toward their destination (this is called routing).
            Strips the Frame header off packet from incoming interface.
            Adds new Frame header to packet for outgoing interface.
_______________________________________________________________________________________________________________________
Administrative Distance
    Routers uses an AD to determine the best source route to install into the IP routing table. The AD represents the "trustworthiness" of the route; the lower the AD, the more trustworthy the route source.
    Fr example, if a router learned about the 10.0.0.0/24 from EIGRP, OSPF and RIP, the EIGRP route entry would be in installed into the routing table. This is because EIGRP AD 90 is lower than OSPF AD 110 and RIP AD 120.
        If anything should happen with the EIGRP route then the OSPF route is installed into the routing table.
-----
Routing Protocol with Metric Name
RIP            Hop count
EIGRP          Bandwidth, Delay, Load, Reliability
OSPF           Cost (Bandwidth)
IS-IS          Cost (Assigned by Admin)
BGP            Policy assigned by Admin
-----
Route AD
Route Source     | Default AD
 Connected        0
 Static           1
 external BGP     20
 EIGRP            90
 OSPF             110
 IS-IS            115
 RIP              120
_______________________________________________________________________________________________________________________
Routed vs Routing Protocols
-Routed protocols allows data to be routed. These protocols provide an addressing scheme and sub-netting.
The addressing scheme identifies the individual host and the network to which it belongs. Each host address must be unique. All hosts on an internetwork must use the services of a routed protocol to communicate.
-Routing Protocols are used by routers to communicate routing information with each other. Unless all routes are manually entered into the router, the router needs to learn from other routers about the networks that they know.
They use this shared information to populate their routing tables so that they can make better decisions when forwarding routed protocols such as IPv4.

Routing Protocols \/\/\/
    Interior Gateway Protocol (IGP) - is a type of protocol used for exchanging routing information between gateways (commonly routers) within an autonomous system
        RIP (v1, v2, ng)
        EIGRP and EIGRP for IPv6
        OSPF (v2 and v3)
        IS-IS
    Exterior Gateway Protocol (EGP) - is a routing protocol used to exchange routing information between autonomous systems
        BGP
_______________________________________________________________________________________________________________________
Distance Vector Routing Protocols
    Distance: This identifies how far away the destination network is from the router and is based on a metric such as the hop count, cost, bandwidth, delay, and more. 
        It takes the learned distance from their neighbor, adds the distance to their neighbor, and this gives them a total distance.
    Vector: This specifies the direction to the remote network. The router advertises a path that it has learned which allows access to a remote network via one of its interfaces.

Link State Routing Protocols
Compared to distance vector routing protocols, a router configured with a link-state routing protocol can create a complete view of the network.
 This is built by gathering information from all of the other routers to build a network topology.
Link state routing protocols tend to flood the network with Link State Advertisements (LSAs). Each router receives these updates and begins to build a map of the entire network.
 It will use its algorithms to compute the best routes from this map to all remote networks. After this is done no periodic updates are sent unless there is a change in the topology.
Link-state protocols work best in situations where:
    The network design is hierarchical, usually occurring in large networks
    Fast convergence of the network is crucial
    The administrators have good knowledge of the implemented link-state routing protocol
There are two link-state IPv4 IGPs:
    OSPF: Popular open standards-based routing protocol
    IS-IS: Popular in service provider networks

_______________________________________________________________________________________________________________________
BGP
BGP is one of only 2 Exterior Gateway Routing Protocols (EGP) created. The other called simply Exterior Gateway Protocol (EGP) was developed in 1982 by Eric C Rosen and David Mills and specified in RFC 827.
   It was a simple protocol that was eventually made obsolete by BGP version 4 published in RFC 4271.
BGP operates differently compared to IGP protocols. Rather than automatically advertising all internal networks, BGP is configured to specify the precise network and CIDR it will advertise. 
   Instead of making best path selection based of metrics, it uses "paths" (which is loosly similar to hops used by RIP), network policies, or rule-sets. This makes BGP one of the most complicated routing protocols to configure.
   Where simple configuration errors with an IGP will have an impact on traffic within your network. Whereas a misconfiguration with BGP could have broad ramifications on the traffic routing throughout the entire world.
Wikipedia BGP link
    Roadmap of the Internet - If DNS is the "address-book" of the Internet then BGP is the Roadmap or "Google Maps" of the Internet. It defines the path all traffic takes through the Internet. 
       The Internet is nothing more than a web of millions of interconnected networks.
    Routes traffic between Autonomous System (AS) Number - Internet Service Providers (ISP) and large organizations are assigned an Autonomous System (AS) Number by IANA.
          Each AS is viewed as a single entity to the rest of the world but within the AS it can contain thousands of subnetworks and routers. List of AS numbers and owners according to bgplokingglass.com
        Think of an AS like a city or town and highways and interstates are the BGP pathways between them.
    Advertises IP CIDR address blocks - Each AS is used to represent a CIDR block(s) of IP addresses and can contain thousands of individual routers and subnetworks.
           Rather than advertise each individual network address and CIDR throughout the AS like IGP do, BGP is manually configured to advertise "summary routes" that encompass all the internal networks. How does BGP work video
        Think of this like street and building numbers in a town or city.
    Establishes Peer relationships - BGP is an application layer protocol that communicates using TCP port 179. ISPs use BGP in order to share routing information with their peers.
            Each ISP’s edge router uses TCP to establish "peer" relationships between other ISP edge routers in another AS to share addressing information. Rather than sending their updates to any BGP listening router, BGP must be manually configured to communicate with 'peer' neighbor routers. This eventually forms a web of communicating routers. APNIC BGP map
    Complicated configuration - Does not operate and share routes automatically like other IGP. Network addresses must be manually configured to be advertised. 
           Due to lack of trust between ISPs they employ series of filters and policies which makes BGP must harder and more complicated to configure.
        This complicated configuration can lead to many errors and attacks over the internet.
    Complicated and slow path selection - BGP uses a series of items in its path determination. BGP path selection reference from CiscoZine.com. "Best Path" in BGP does not mean its the most optimal path.
          It only routes by AS #'s and not the attributes within the AS themselves. Typically BGP prefers the route that takes the packet through the fewest amount of AS’s.

_______________________________________________________________________________________________________________________
First hop redundanc protocols
Hot Standby Router Protocol (HSRP)
A Cisco-proprietary FHRP designed to allow for transparent fail-over of IPv4 networks.
Defined in RFC 2281.
One router interface will be set as "active" and the others set as "standby".
Once the active interface will forward traffic to other networks.
Standby interfaces serve as backups in case the active fails.
Active interface sends multicast "Hello" packets to inform the backups that its still operational.
IPv4: HSRP for IPv4 operates on the default multicast address 224.0.0.2 (v1) or 224.0.0.102 (v2).
IPv6: HSRP for IPv6 operates on the multicast address ff02::66.
HSRP States
    Initial: The initial state when the router has not yet started HSRP.
    Learn: The router has not yet learned the virtual IP address.
    Listen: The router has learned the virtual IP address but is not yet the active or standby router.
    Speak: The router is participating in the HSRP election process and sending hello messages.
    Standby: The router is ready to take over as the active router if needed.
    Active: The router is currently handling traffic and serving as the default gateway for the virtual IP address.
Timers
    Hello Timer: Controls how frequently HSRP hello messages are sent between routers. Default is 3 seconds.
    Hold Timer: Defines how long a router will wait for hello messages before declaring the active router to be down. Default is 10 seconds.
    Goodbye Timer: Used by the active router to notify the standby router of its impending failure. This is an optional feature in HSRP.
Virtual Router Redundancy Protocol
    An industry-standard protocol defined in RFC 3768 that offers similar functionality to HSRP.
    Like HSRP, VRRP allows multiple routers to work together to provide redundancy for the default gateway.
    One router is elected as the master router, and the others are backup routers.
    The master router sends periodic advertisements to inform the backup routers of its status.
    If the master router fails, one of the backup routers is elected as the new master.
    IPv4: VRRP for IPv4 operates on the default multicast address 224.0.0.18.
    IPv6: VRRP for IPv6 operates on the multicast address ff02::12.
    VRRP States
        Initialize: The router has not yet started VRRP.
        Backup: The router is a backup and will take over if the master fails.
        Master: The router is the active router handling traffic for the virtual IP address.
    Timers
        Advertise Interval: Defines how frequently the master router sends VRRP advertisements to inform backup routers of its status. The default interval is 1 second.
        Master Down Interval: The time a backup router waits after not receiving advertisements before assuming the master router has failed. The default is 3 times the advertise interval.
    Versions
        VRRPv1 - Defined in RFC 2338, VRRPv1 was the original version of the protocol.
            VRRPv1 supports IPv4 only.
            Uses an 8-bit virtual router identifier (VRID), which limits the number of virtual routers to 256.
            Lacks support for authentication, which can lead to potential security issues.
            Provides basic router redundancy with failover and virtual IP address sharing.
        VRRPv2 - Defined in RFC 3768, VRRPv2 builds on VRRPv1 with several improvements.
            VRRPv2 still supports IPv4 but with enhanced features over VRRPv1.
            Uses a 256-bit VRID, allowing more flexibility in configuration.
            Adds support for MD5 authentication to secure VRRP advertisements and prevent unauthorized routers from participating.
            Supports preemption, allowing a higher-priority router to take over as the master if it becomes available.
            Improves stability and robustness over the original VRRPv1 implementation.
        VRRPv3 - Defined in RFC 5798, VRRPv3 extends VRRP to support IPv6 in addition to IPv4.
            Provides support for IPv6 addresses, which is essential for modern networks transitioning to IPv6.
            Uses the multicast address ff02::12 for IPv6 communication.
            Maintains a 256-bit VRID, similar to VRRPv2.
            Continues to support MD5 authentication and extends security features.
            Includes additional capabilities for more sophisticated network environments.
Gateway Load Balancing Protocol (GLBP)
    GLBP is another Cisco proprietary protocol that extends the functionality of HSRP and VRRP by providing load balancing in addition to redundancy.
    GLBP allows multiple routers to share the traffic load for a virtual IP address, providing both redundancy and increased network capacity.
    GLBP uses an active virtual gateway (AVG) to assign different virtual MAC addresses to different routers, distributing traffic across multiple gateways.
    Cisco introduced IPv6 support in IOS release 12.2(33)SXI in August 2007.
    IPv4: GLBP for IPv4 operates on the default multicast address 224.0.0.102.
    IPv6: GLBP for IPv6 operates on the multicast address ff02::66.
    GLBP States
        Initialization: The router has not yet started GLBP.
        Listen: The router has received GLBP advertisements but has not yet assumed any role.
        Speak: The router is participating in the election process and sending advertisements.
        Active: The router is the AVG and is managing load balancing and redundancy.
        Standby: The router is a backup for the AVG and will take over if the AVG fails.
    Timers
        Hello Timer: Defines how frequently GLBP hello messages are sent. Default is 3 seconds.
        Hold Timer: Defines how long a router waits for hello messages from the AVG before considering it down. Default is 10 seconds.
    Load Balancing Methods
        Round-Robin: Distributes traffic evenly across all available routers.
        Weighted Load Balancing: Allows routers to be assigned different weights, with traffic distributed based on these weights.
        Host-Based Load Balancing: Distributes traffic based on the MAC address of the requesting host, which can help to achieve more balanced traffic distribution
_______________________________________________________________________________________________________________________
Port Ranges
0-1023 Well Known(system)
1024-49151 Registered(users)
49152-65535 Dynamic(private)

TCP 3 WAY HANDSHAKE
Syn -> Syn,Ack -> Ack

Udp    
0-1    Source Port    0-15    16 bits
Specifies the port that localhost is listening on for traffic during this communication.
2-3    Destination Port    16-31    16 bits
Specifies the port on the receiving(destination) host that it is listening on for this communication.
4-5    Length    32-47    16 bits
Specifies the length of the UDP header and data.
6-7    Checksum    48-63    16 bits
Used for error checking of the header and data. This is optional for IPv4 and mandatory in IPv6.
_______________________________________________________________________________________________________________________
VPN
Virtual Private Networks (VPN) allows connections through a network that is not accessible to everyone else.
This "private" connection makes is look like a direct connection, when in fact it is not. VPNs work by encapsulating an IP packet into another IP packet for traversal across a (generally) public network.
The outer IP packet headers used for the traversal is then removed and the original packet headers are then used for further routing decisions.
VPN Connection

VPN connections are typically unencrypted but can be secured using encryption, such as IPSEC or TLS/SSL, to make it more secure for sensitive information.
Some protocols used to provide confidentiality for VPN tunnels.
    IPsec: Provides a suite of protocols for secure IP communication, including Authentication Header (AH), Encapsulating Security Payload (ESP), and Internet Key Exchange (IKE).
    SSL/TLS: Utilizes the SSL/TLS protocol suite to create secure connections between clients and servers, commonly used in SSL VPNs.
    OpenVPN: An open-source VPN protocol that uses SSL/TLS for encryption and authentication, known for its flexibility and cross-platform compatibility.

TYPES OF VPN
    Remote Access VPN (Client-to-Site VPN):
        Allows individual users to securely connect to a private network from remote locations over the internet.
        These VPNs are commonly used by employees working from home or while traveling to access company resources such as files, applications, and internal systems.
        Remote access VPNs typically use protocols like SSL/TLS or IPsec to create encrypted tunnels between the user’s device and the corporate network.
        Uses OpenVPN, IPsec, or Wireguard installed on the client system to create the tunnel to the Network Access Server in the main office.

    Site-to-Site VPN: (aka router-to-router VPN)
        Connects multiple sites or networks together over the internet, creating a secure communication link between them.
        Site-to-site VPNs are commonly used to connect branch offices to a central headquarters, or to connect geographically distributed data centers.
        Can be configured as point-to-point, point-to-multipoint, or full mesh.
        Uses IPSEC, MPLS, SSL, PPTP, L2TP, and others to create the tunnel.
_______________________________________________________________________________________________________________________
L2TP (TCP 1701)
    Layer Two Tunneling Protocol (L2TP) serves as an extension of the Point-to-Point Tunneling Protocol (PPTP) commonly employed by internet service providers (ISPs) to establish virtual private networks (VPNs).
The primary objective of L2TP is to enable secure data transmission through the creation of tunnels. To uphold security and privacy standards, L2TP necessitates the use of an encryption protocol within the established tunnel.
    L2TP exhibits the capability to transport a diverse range of Layer 2 (L2) data types across an Internet Protocol (IP) or Layer Three (L3) network. 
The initiation of this process involves the establishment of a tunnel connecting an L2TP Access Concentrator (LAC) and an L2TP Network Server (LNS) on the internet. 
This configuration facilitates the implementation of a Point-to-Point Protocol (PPP) link layer, which is encapsulated and seamlessly transferred across the internet for secure and efficient communication.
_______________________________________________________________________________________________________________________
 PPTP (TCP 1723)
    Point-to-Point Tunneling Protocol (PPTP) stands as a foundational networking protocol that empowers the secure deployment of Virtual Private Networks (VPNs) over the Internet. Conceived by Microsoft and collaborative contributors, 
PPTP is intricately designed to forge a private and encrypted communication conduit between clients and servers, guaranteeing the secure transmission of data.
    Authentication Mechanisms: PPTP boasts support for a range of robust authentication mechanisms, including Password Authentication Protocol (PAP), Challenge Handshake Authentication Protocol (CHAP), and Microsoft CHAP (MS-CHAP). 
These mechanisms play a pivotal role in fortifying the verification processes, ensuring the genuine identity of the connecting parties.
    Encapsulation and Encryption Expertise: PPTP demonstrates its prowess by encapsulating data within its proprietary packets, establishing a secure tunnel for data transmission. 
Furthermore, it incorporates encryption protocols such as Microsoft Point-to-Point Encryption (MPPE) to safeguard the confidentiality of the transmitted data. 
This dual-layered approach enhances the privacy and integrity of the communication channel.
    Awareness of Limitations: Recognizing its historical prevalence, it’s crucial to acknowledge the limitations associated with PPTP. 
While it was widely adopted in the past, PPTP has exhibited security vulnerabilities, prompting a gradual decline in usage. Organizations and users have increasingly favored more secure VPN protocols like L2TP/IPsec and
OpenVPN to address evolving security standards and ensure a higher level of data protection.
_______________________________________________________________________________________________________________________
IP Security (IPSec)
IPsec (Internet Protocol Security) is a suite of protocols used to secure IP communications by providing encryption, authentication, and integrity protection at the network layer (Layer 3) of the OSI model.
It is widely used to establish Virtual Private Networks (VPNs) and secure data transmission over IP networks, including the internet.
Transport mode and Tunnel mode are two operational modes of IPsec (Internet Protocol Security) used to provide security for IP communications.
  "TWO MODES"
    Transport Mode:
        In Transport mode, IPsec only encrypts the payload (data) of the original IP packet, leaving the original IP header intact.
        Transport mode is typically used for end-to-end communication between two hosts or devices.
        When using Transport mode, only the data portion of the IP packet is protected by IPsec, while the original IP header, including the source and destination IP addresses, remains visible to intermediate devices.
        Transport mode is often used for scenarios where the communicating endpoints need to establish a secure connection while maintaining direct communication with each other.
        Example use cases for Transport mode include securing communication between individual hosts or devices within a private network or securing VoIP (Voice over IP) traffic between two endpoints.
    Tunnel Mode:
        In Tunnel mode, IPsec encapsulates the entire original IP packet within a new IP packet, adding an additional IP header. Tunnel mode is commonly used to create secure VPN (Virtual Private Network) connections between networks or network devices, such as routers or firewalls.
        When using Tunnel mode, the original IP packet, including its header and payload, is encrypted and encapsulated within a new IP packet.
        The new IP header contains the IP addresses of the VPN gateway devices (tunnel endpoints), which are responsible for encrypting and decrypting the data as it passes through the VPN tunnel.
        Tunnel mode provides network-level security, ensuring that all traffic between the VPN gateway devices is encrypted and protected from eavesdropping or tampering.
        Example use cases for Tunnel mode include connecting branch offices to a central headquarters network over the internet, creating secure connections between remote users and a corporate network, or establishing site-to-site VPN connections between data centers.
_______________________________________________________________________________________________________________________
OpenVPN
OpenVPN is an open-source VPN (Virtual Private Network) software that provides secure communication over the internet by creating encrypted tunnels between devices or networks. It is widely used for remote access VPNs, site-to-site VPNs,
and other secure networking applications.
OpenVPN requires special software that implements the OpenVPN protocol. There are client and server versions. The client software runs on your device (computer, phone, etc.) and the server software runs on the VPN provider’s server. 
This software creates the encrypted tunnel and manages the data transmission.
It’s known for being very secure due to strong encryption algorithms and multiple authentication methods. OpenVPN uses the OpenSSL library to provide encryption of both the data and control channels.
It offers a high degree of customization, making it suitable for a wide range of uses. Because of the customization options, setting up OpenVPN can be more complex for non-technical users compared to some other VPN solutions.
    OpenVPN can be configured to use UDP or TCP as it’s transport layer protocols:
        UDP Protocol (Default):
            OpenVPN often uses UDP for communication, providing a lightweight and connectionless transport protocol suitable for VPNs.
            The default UDP port number for OpenVPN is 1194.
        TCP Protocol:
            OpenVPN can also be configured to use TCP for communication, which can be useful in scenarios where UDP traffic is restricted or blocked.
            The default TCP port number for OpenVPN is 1194, but it can be configured to use other port numbers such as port 443.
_______________________________________________________________________________________________________________________
Understand proxies

    A proxy, or proxy server, functions as a vital intermediary that stands between a user’s device, be it a computer or smartphone, and the vast expanse of the internet. Operating as a sophisticated gateway,
    it expertly facilitates the exchange of requests and responses between the user and the destination server,
    seamlessly navigating the intricate web of online communication. Proxies, with their multifaceted capabilities, empower users and organizations by delivering anonymity, content filtering, and performance optimization.
    In this dynamic role, proxies serve as instrumental guardians of privacy, gatekeepers for access control,
    and enhancers of overall internet efficiency.
      This allows for your device’s information, such as IP address and possibly your MAC address, to stay hidden. Besides privacy, a proxy can provide additional benefits such as load balancing or security.
      When utilizing proxies for secure communications, we must remember that the client only creates a secure connection to the proxy, and the proxy will create the secure connection with the remote server. 
      This means that if the proxy server should be compromised, the data communication can be intercepted.
Typical communication with a proxy server is done over TCP port 1080 but The Onion Router (TOR) browsing uses TCP port 9050 by default.
    Here are key aspects of a proxy:
        Anonymity: One of the primary functions of a proxy is to provide anonymity for the user. When you connect to a website through a proxy, the website sees the IP address of the proxy server rather than your actual IP address.
                   This can be useful for privacy and security reasons.
        Content Filtering: Proxies can be configured to filter and block access to specific content or websites. This is often employed in organizations and institutions to control and monitor internet usage.
        Access Control: Proxies can control access to certain resources based on predefined rules. This allows administrators to restrict or grant access to specific websites, services, or content.
        Improved Performance: In some cases, proxies can improve network performance by caching frequently requested content. When a user requests a resource that has been cached, the proxy can deliver it directly,
                reducing the load on the destination server and improving response times.
        Security: Proxies can enhance security by acting as a barrier between the user and the internet. They can filter out malicious content, block access to known malicious websites, and provide an additional layer of defense against cyber threats.
        Load Balancing: Proxies can distribute incoming network traffic across multiple servers, helping to balance the load and ensure efficient utilization of resources. This is known as load balancing and can improve the overall performance and reliability of a network.
    Types of Proxies:
        Forward Proxy: Acts on behalf of clients, typically used to access the internet.
        Reverse Proxy: Acts on behalf of servers, often used to distribute incoming client requests to multiple servers.
        Transparent Proxy: Operates without altering the request or response, providing anonymity.
        Anonymous Proxy: Hides the user’s IP address but informs the server that a proxy is being used.
        Elite or High-Anonymous Proxy: Provides the highest level of anonymity by not disclosing the use of a proxy.
_______________________________________________________________________________________________________________________
Examine SOCKS protocol
Socks 4/5 (TCP 1080)socks
    SOCKS (Socket Secure) is a protocol that facilitates communication between clients and servers through a proxy server.
        Initiates connections through a proxy
        Uses various Client / Server exchange messages
        Client can provide authentication to server
        Client can request connections from server
        Defined in RFC 1928
        Versions:
            SOCKS4
                Initial version of the SOCKS protocol, introduced in the early 1990s.
                No Authentication, meaning that it does not require clients to authenticate themselves before connecting to the proxy server.
                Only IPv4
                Only TCP support. No UDP support.
                No Proxy binding. Client’s IP is not relayed to destination.
            SOCKS5
                Support for Authentication, allowing clients to authenticate themselves using various methods, such as username/password,
                GSS-API (Generic Security Services Application Program Interface), or digital certificates.
                IPv4 and IPv6 support
                TCP and UDP support
                Supports Proxy binding. Client’s IP is relayed to destination.
_______________________________________________________________________________________________________________________
Examine Network Basic Input Output System (NetBIOS) protocol
    -NetBIOS, an acronym for Network Basic Input/Output System, emerged as a protocol suite crafted by IBM during the early 1980s.
This suite offers a collection of services along with an application programming interface (API), facilitating network communication across local area networks (LANs).
Initially conceived for IBM’s PC Network, NetBIOS eventually evolved into a de facto standard for LAN communication within the Microsoft Windows ecosystem.
    -NetBIOS provides services related to the session layer of the OSI model allowing applications on separate computers to communicate over a local area network. 
The outputs from NetBIOS can provide computer names, group assignments, and MAC addresses of nodes.
    -NetBIOS vs. DNS: The Domain Name System (DNS) is a directory for communication between devices over the internet.
An internet connection is required to use DNS, but NetBIOS is available to all machines on a local area network. 
If a windows system is unable to resolve  name via DNS, then it will look for a WINS server, then finally uses NetBIOS.
______________________________________________________________________________________________________________________
Examine Server Message Block (SMB) protocol
SMB/CIFS (TCP 139/445 AND UDP 137/138)
    The Server Message Block (SMB) protocol serves as a communication protocol predominantly utilized by Microsoft Windows-equipped computers. Its primary function is to facilitate the sharing of files, printers, serial ports, and various communications among network nodes. For user authentication, SMB employs either the NTLM or Kerberos protocols.
    Additionally, SMB offers an authenticated inter-process communication (IPC) mechanism. Originally conceived in 1983 by Barry A. Feigenbaum at IBM, SMB aimed to provide shared access to files and printers within a network of systems running IBM’s OS/2.
    Subsequently, in 1987, Microsoft and 3Com implemented SMB in LAN Manager for OS/2. During this period, SMB utilized the NetBIOS service atop the NetBIOS Frames protocol as its foundational transport. Over time, Microsoft integrated SMB into Windows NT 3.1, continuously updating it to function with newer underlying transports, such as TCP/IP and NetBT. A notable development is the introduction of SMB over QUIC, which made its debut in Windows Server 2022.
smb
smbclient -L <IP Address>
    Allowed devices to establish connections to other devices on network to share files, printers and other things.
    Several versions since its release in 1984:
        SMBv1 was released in 1984 by IBM for file sharing in DOS. Modified by Microsoft in 1990 for integration into Windows GUI.
        CIFS was released in 1996. Microsoft launched an initiative to rename SMB to Common Internet File System (CIFS).
Included more features and support for symbolic links, hard links, larger file sizes. Rolled out with Windows 95.
        SMBv2.0 debuted in 2006 for Windows Vista. It featured a notable boost in performance because of increased efficiency — fewer commands and subcommands meant better speeds.
        SMBv2.1 released with Windows 7, bringing improved performance.
        SMBv3.0 released with Windows 8 with many updates. Most notable of which is enhanced security — the protocol started supporting end-to-end encryption.
        SMBv3.0.2 released with Windows 8.1. It offered the ability to increase security and performance by completely disabling SMBv1.
        SMBv3.1.1 was released in 2015 with Windows 10. It added more security elements to the protocol, like AES-128 encryption, protection
from man-in-the-middle attacks, and session verification.
    SMB Rides over Netbios - allows applications to communicate over a LAN using a NetBIOS name. Depricated due to DNS. Netbios Wiki
        Netbios Dgram Service - UDP 138
        Netbios Session Service - TCP 139
    Third-Party SMB Implementations:
        SAMBA
            (Samba Wiki)
            Developed to offer file and print services for Windows clients on Unix-based systems, including Linux and other Unix variants.
            Facilitates seamless interaction between Unix-based systems and Windows networks, providing features like file sharing, printer services, and authentication.
            Enables Unix-based servers to function as file and print servers within a Windows network, ensuring compatibility and interoperability.
            Samba is compatible with a wide range of Unix-based operating systems, encompassing Linux, Solaris, AIX, and various BSD variants, including Apple’s macOS Server and macOS client (Mac OS X 10.2 and later).
            Supports various versions of the SMB protocol, allowing non-Windows systems to actively participate in Windows networking environments.
        Netsmb
            NSMB, which encompasses Netsmb and SMBFS, constitutes a group of in-kernel SMB client implementations within BSD operating systems. * Originally introduced by Boris Popov in FreeBSD 4.4,
            this family of implementations has proliferated across various BSD systems, including NetBSD and macOS.
            Over time, these implementations have undergone significant divergence.
        NQ
            NQ stands as a suite of portable SMB client and server implementations crafted by Visuality Systems, an Israel-based company founded in 1998 by Sam Widerman, 
            who previously served as the CEO of Siemens Data Communications.
        MoSMB
            MoSMB is a proprietary SMB implementation designed for Linux and other Unix-like systems, created by Ryussi Technologies. It exclusively supports SMB versions 2.x and 3.x.
___________________________________________________________________________________________________________________________________________________________________________
LAYER 6
    Presentation Layer - This layer deals with the Translating, Formatting, Encryption, and Compression of data.
        Data Translation and Transformation:
            The Presentation Layer can translate data between different character encoding schemes, such as ASCII, Unicode, EBCDIC, etc., ensuring compatibility between systems with different encoding requirements.
                ASCII Encoding: American Standard Code for Information Interchange represents text characters using 7 or 8 bits, mapping each character to a numeric value.
                Unicode Encoding: A character encoding standard that encompasses most of the world’s writing systems, assigning unique numerical values to characters, emojis, and symbols.
                UTF-8 Encoding: A variable-width character encoding capable of encoding all Unicode characters using one to four bytes, commonly used in web pages and email.
                UTF-16 Encoding: A character encoding capable of encoding all Unicode characters using two or four bytes, often used in programming languages like Java and JavaScript.
                UTF-32 Encoding: A fixed-width encoding scheme that represents each Unicode code point with four bytes, ensuring straightforward indexing but resulting in larger file sizes compared to UTF-8 and UTF-16.
                Base64 Encoding: Converts binary data into ASCII characters, useful for encoding binary data such as images or attachments in emails or transmitting binary data over text-based protocols.
                URL Encoding: Converts special characters into a format that can be transmitted over the Internet, replacing reserved characters with percent-encoded representations.
        Data Formatting and Syntax Parsing:
            The Presentation Layer can format data according to predefined standards or protocols, ensuring that the data conforms to the expected syntax and structure. It parses the incoming data to extract relevant information and present it to the application layer in a meaningful way.
                Text-Based Formats:
                    Plain Text (.txt): Simplest format containing unformatted text without any styling or formatting.
                    Comma-Separated Values (.csv): Tabular format where data values are separated by commas, commonly used for storing and exchanging spreadsheet or database data.
                    Extensible Markup Language (.xml): Markup language for encoding structured data in a human-readable format, widely used in web services, configuration files, and data exchange.
                    JavaScript Object Notation (.json): Lightweight data interchange format commonly used for transmitting data between a server and a web application, as well as storing configuration data.
                Document Formats:
                    Portable Document Format (.pdf): A format developed by Adobe that preserves document formatting and layout across different platforms, widely used for sharing and distributing documents.
                    Microsoft Word Document (.docx): Word processing format developed by Microsoft, used for creating and editing text-based documents with rich formatting, images, and other multimedia elements.
                    Rich Text Format (.rtf): Cross-platform document format that supports text formatting, images, and other media, compatible with various word processors.
                Image Formats:
                    Joint Photographic Experts Group (.jpg/.jpeg): Commonly used format for storing compressed digital images, suitable for photographs and complex images with many colors.
                    Graphics Interchange Format (.gif): Format supporting animated images and short video clips, widely used for web animations and memes.
                    Portable Network Graphics (.png): Lossless image format that supports transparency and compression, commonly used for web graphics and digital images.
                Audio Formats:
                    MP3 (.mp3): Compressed audio format that reduces file size while preserving audio quality, widely used for storing and sharing music and audio files.
                    Waveform Audio File Format (.wav): Uncompressed audio format that preserves original audio data without loss of quality, commonly used for professional audio editing and recording.
                    Advanced Audio Coding (.aac): Format for encoding digital audio data, known for its high compression efficiency and widespread support in multimedia applications.
                Video Formats:
                    Moving Picture Experts Group-4 (.mp4): Standard format for storing digital video and multimedia content, widely supported by video playback software and devices.
                    Audio Video Interleave (.avi): Multimedia container format developed by Microsoft, capable of storing audio and video data in a single file, commonly used for video editing and playback.
                    Flash Video (.flv): Format developed by Adobe for streaming video content over the internet, commonly used for web-based video players and online streaming platforms.
        Data Encryption and Decryption:
            The Presentation Layer can perform encryption and decryption of data to ensure its confidentiality and integrity during transmission. It encrypts data before transmission and decrypts it upon receipt, allowing secure communication between systems.
                Symetric: AES, Blowfish, Twofish, DES, and RC4
                Asymetric: PKI, Diffie-Hellman, DSS, RSA, Elliptic curve
                TLS (Transport Layer Security):
                    TLS is primarily a transport layer protocol that provides secure communication over a network. However, cryptographic algorithms used in TLS (such as RSA, Diffie-Hellman, and AES) may be invoked at the presentation layer for encrypting data before presentation to the user.
                    In web browsers, TLS encryption ensures secure communication between the client and server, protecting sensitive data such as login credentials, payment information, and personal details during transmission.
                SSL (Secure Sockets Layer):
                    SSL is the predecessor to TLS and operates similarly to TLS in providing secure communication over a network. Like TLS, SSL may involve cryptographic operations at the presentation layer to encrypt data before rendering.
                    Although SSL has been largely deprecated in favor of TLS, some legacy systems and applications may still use SSL for securing data.
                PGP (Pretty Good Privacy):
                    PGP is an encryption program that provides cryptographic privacy and authentication for data communication. It can be used for encrypting and decrypting emails, files, and other forms of data.
                    While PGP is commonly associated with email encryption (which operates at the application layer), it may also involve cryptographic operations at the presentation layer for rendering encrypted messages in email clients.
                S/MIME (Secure/Multipurpose Internet Mail Extensions):
                    S/MIME is a standard for secure email messaging that provides encryption and digital signature functionality. It enables users to send encrypted and digitally signed emails using cryptographic algorithms such as RSA and AES.
                    S/MIME operations may involve cryptographic processing at the presentation layer for rendering encrypted email messages and verifying digital signatures.
                OpenPGP (Open Pretty Good Privacy):
                    OpenPGP is an open-source standard that builds upon PGP for secure communication. It defines formats for encrypted messages, digital signatures, and key management.
                    OpenPGP implementations may involve cryptographic operations at the presentation layer for rendering encrypted messages and verifying digital signatures.
                End-to-End Encryption (E2EE):
                    E2EE is a method of secure communication that ensures only the communicating users can read the messages. Encryption and decryption occur exclusively at the endpoints, providing strong confidentiality guarantees.
                    While E2EE is typically implemented at the application layer, cryptographic techniques used for encryption and decryption may involve operations at the presentation layer for data rendering.
        Data Compression and Decompression:
            The Presentation Layer can compress data to reduce its size before transmission, optimizing network bandwidth and speeding up data transfer. It decompresses the data upon receipt, restoring it to its original format.
            Sometimes data gets to big to transmit over the network so the Presentation layer handles compression.The primary role of Data compression is to reduce the number of bits to be transmitted. It is important in transmitting multimedia such as audio, video, text etc.
                Zip, TAR, RAR, 7zip, CAB
            Lossless Compression:
                Lempel-Ziv (LZ) Compression: This family of algorithms, including LZ77 and LZ78, identifies repeated patterns in the data and replaces them with shorter codes, achieving compression without loss of information.
                DEFLATE Compression: DEFLATE combines LZ77 with Huffman coding and is used in popular formats like ZIP, gzip, and PNG for lossless compression.
                Run-Length Encoding (RLE): RLE replaces sequences of repeated data with a single value and a count, making it effective for compressing data with long runs of identical values.
                Burrows-Wheeler Transform (BWT): BWT rearranges the characters in the input data to facilitate compression. It’s often used in conjunction with other techniques like Move-to-Front (MTF) and Huffman coding.
                Huffman Coding: Huffman coding generates variable-length codes for characters based on their frequencies in the input data, achieving efficient compression without loss of information.
                Arithmetic Coding: Arithmetic coding encodes a sequence of symbols into a single floating-point number within a specified range, offering high compression ratios for lossless data.
                Bzip2 Compression: Bzip2 uses the Burrows-Wheeler Transform (BWT) and Huffman coding to achieve high compression ratios, particularly effective for compressing text files.
                Delta Encoding: Delta encoding compresses data by encoding the differences between consecutive values in a sequence, suitable for compressing data with predictable patterns or incremental updates.
                PPM (Prediction by Partial Matching): PPM predicts the next symbol in a sequence based on its context, achieving high compression ratios for text and structured data.
                LZMA (Lempel-Ziv-Markov chain Algorithm): LZMA combines LZ77 with additional modeling techniques like Markov chains for high compression ratios, commonly used in formats like 7z and XZ.
                LZ77 and LZ78: These are foundational algorithms in the LZ family, used for identifying and encoding repeated patterns in data for compression.
                Shannon-Fano Coding: Similar to Huffman coding, Shannon-Fano coding generates prefix codes based on symbol probabilities to achieve lossless compression.
                Gzip Compression: Gzip uses DEFLATE compression and is commonly used for compressing files on Unix-based systems.
                Zstandard (Zstd): Zstd is a modern compression algorithm that offers a good balance between compression speed and ratio, suitable for various types of data.
                LZW (Lempel-Ziv-Welch) Compression: LZW is used in formats like GIF and compresses data by replacing repeating patterns with codes from a dictionary.
                CAB (Cabinet File Format): CAB is a Microsoft-developed file archive format commonly used for software installation packages and system files, often employing the LZX compression algorithm.
            Lossy Compression:
                JPEG Compression: JPEG (Joint Photographic Experts Group) is widely used for compressing digital images. It achieves compression by discarding high-frequency information and optimizing color representation, resulting in smaller file sizes but some loss of image quality.
                GIF Compression: Although GIF (Graphics Interchange Format) primarily supports lossless compression, it can also be used in a lossy mode by reducing the color palette or by discarding color information. This can result in smaller file sizes but may degrade image quality, particularly for complex images.
                MPEG Compression: MPEG (Moving Picture Experts Group) is a suite of standards for compressing audio and video data. It typically uses lossy compression techniques such as motion compensation, discrete cosine transform (DCT), and quantization to achieve compression while maintaining perceptual quality.
                MP3 Compression: MP3 is a popular lossy compression algorithm for audio data. It achieves compression by removing parts of the audio signal that are less audible to humans, such as frequencies outside the normal hearing range and quiet sounds masked by louder ones.
                AAC (Advanced Audio Coding): AAC is a more advanced audio compression format compared to MP3. It offers better sound quality at lower bit rates and is commonly used for streaming audio and digital music distribution.
                OGG Compression: OGG is a container format that typically uses lossy compression for audio data. It’s often associated with the Vorbis codec, which offers high-quality audio compression at lower bit rates compared to formats like MP3.
                WebP Compression: WebP is an image format developed by Google that uses both lossy and lossless compression techniques. It’s designed to offer smaller file sizes and faster loading times for web images compared to formats like JPEG and PNG.
                HEVC (High-Efficiency Video Coding): HEVC, also known as H.265, is a video compression standard that offers better compression efficiency compared to previous standards like H.264. It’s widely used for streaming video and digital television.
                FLAC (Free Lossless Audio Codec): Although FLAC is primarily a lossless compression format, it can also be used in a lossy mode where certain non-essential audio data is discarded to achieve smaller file sizes while still retaining high audio quality.
                WAVPACK: WAVPACK is a hybrid audio compression format that offers both lossy and lossless compression modes. It’s capable of achieving high compression ratios while preserving audio quality through its lossy mode.
                DCT (Discrete Cosine Transform) Compression: DCT is commonly used in lossy compression algorithms for images and video, such as JPEG and MPEG. It transforms spatial data into frequency domain coefficients, allowing for efficient compression while sacrificing some image or video quality.
__________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________
____________________________________________________________________________________________________________________________________________________________________________________________________________________________________________
______________________________________________________________________________________________________________________

Telnet TCP 23
- ABsolute TRaSh
SSH TCP 22 
    Asymmetric Encryption:
        Key Exchange: When an SSH connection is initiated, the client and server perform a key exchange protocol (such as Diffie-Hellman key exchange).
            This protocol allows them to securely establish a shared secret key over an insecure network. Asymmetric encryption algorithms (such as RSA or Elliptic Curve Cryptography) are used during this process.
            Key Exchange Algorithms:
                Diffie-Hellman (DH): A key exchange algorithm used to establish a shared secret key between the client and server during the initial connection setup.
                Elliptic Curve Diffie-Hellman (ECDH): A variant of Diffie-Hellman that uses elliptic curve cryptography for key exchange, offering strong security with smaller key sizes compared to traditional DH.
                Curve25519: A specific elliptic curve algorithm designed for efficient and secure key exchange.
        Authentication: SSH also employs asymmetric encryption for user authentication. The client and server exchange public keys during the key exchange phase, and the client uses its private key to sign a challenge provided by the server.
                        The server verifies the client’s identity by checking the signature against the client’s public key.
            Public Key Algorithms:
                RSA (Rivest-Shamir-Adleman): A widely used public key algorithm for digital signatures and encryption. SSH uses RSA for key authentication and digital signatures.
                DSA (Digital Signature Algorithm): An older public key algorithm, less commonly used in SSH compared to RSA.
                ECDSA (Elliptic Curve Digital Signature Algorithm): A variant of DSA that uses elliptic curve cryptography for digital signatures, offering strong security with smaller key sizes.
    User Keys:
        User keys are associated with individual users and are used for user authentication. They are typically generated by the client (user) and stored on the client-side.
        User keys are asymmetric, consisting of a public key and a private key pair.
        The user’s private key is kept securely on the client’s machine, while the public key is uploaded to the remote server.
        Clents send their asymmetric public keys to the server to identify themselves to the server.
    Host Keys:
        Host keys, also known as server keys, are associated with SSH servers.
        They serve as an identifier and ensure the integrity of the server during the initial connection.
        Host keys are generated on the server-side and are used to verify the server’s identity and protect against man-in-the-middle attacks.
        Servers send their asymmetric public keys to the client to identify themselves to the client.
        These host keys are saved by the Linux client into the /home/<user>/.ssh/know_hosts file.
   
Symmetric Encryption:
        Session Key:
            Once the asymmetric public key exchange is completed, the client will derive the shared symmetric session key.
            The client encrypt the session key using the public key (host key) of the server and send it to the server.
            Once the server decrypts the session key using its private key they will use symmetric encryption for the remaining duration of the SSH session.
            A symmetric encryption algorithm (such as AES) is commonly used to encrypt the session data.
            The shared secret key is securely generated from the key exchange process and shared only between the client and server.
            Symmetric Encryption Algorithms:
                AES (Advanced Encryption Standard): A widely used symmetric encryption algorithm known for its security and efficiency. SSH supports various key lengths (e.g., AES-128, AES-192, AES-256) for AES encryption.

Configuration File: Settings that exist on either the client or server that dictate functionality for ssh or sshd respectively
    Client Configuration File (~/.ssh/config or /etc/ssh/ssh_config): The client-side SSH configuration file allows users to specify settings for SSH connections initiated from the local system.
    Server Configuration File (/etc/ssh/sshd_config): The server-side SSH configuration file specifies settings and options for the SSH daemon (sshd) running on the remote server.
    Known Hosts File (~/.ssh/known_hosts): The known hosts file stores the public keys of remote hosts that the SSH client has previously connected to.

    -p {port} = This specifies the alternate port to be used. When connecting to a server the assumed default port to connect to is port 22. Should you need to specify a different port then the -p switch is used followed by the port.
        Assuming the SSH port of 172.16.82.106 was 1234. ssh student@172.16.82.106 -p 1234
        If you already had an SSH tunnel created you can call on that port to authenticate to the server on the other end. ssh student@localhost -p 1234
    -l {username} = This is to specify the username to use when authenticating to the remote server. This is the same as {username]@{ip}. ssh 172.16.82.106 -l student
    {command} = Optional command to execute on the remote host after establishing the SSH connection. If provided, SSH will execute the command on the remote host and then return the output to the local terminal. If not provided, SSH will start an interactive shell session on the remote host. ssh student@172.16.82.106 cat /etc/passwd
    -X = This will enable X11 graphics to be forwarded from the server to the client. This will allow you to open graphical applications such as pcmanfm, gimp, eog, eom, firefox, terminator, and more. ssh student@172.16.82.106 -X
    -v = Enables verbose mode, which provides detailed debugging information about the SSH connection process. This can be helpful for diagnosing connection issues or troubleshooting SSH configuration problems. ssh student@172.16.82.106 -v
    -f = Requests SSH to go to the background just before command execution. This is useful when running SSH commands as part of scripts or automation tasks. This is not to be confused with the & option which is used to background most applications. ssh student@172.16.82.106 -f
    -i {identity file} = Selects a file from which the identity (private key) for RSA or DSA authentication is read. The default is ~/.ssh/identity for protocol version 1, and ~/.ssh/id_rsa and ~/.ssh/id_dsa for protocol version 2. ssh student@172.16.82.106 -i idfile.pub
    -F {config file} = Specifies an alternative per-user configuration file. If a configuration file is given on the command line, the system-wide configuration file (/etc/ssh/ssh_config) will be ignored. The default for the per-user configuration file is ~/.ssh/config. ssh student@172.16.82.106 -F my.config
    -N = Requests that no command be executed on the remote server after establishing the SSH connection. This can be useful when setting up port forwarding or establishing a tunnel without running a command on the remote server. ssh student@172.16.82.106 -NT
    -T = Disables pseudo-terminal allocation, preventing the allocation of a terminal on the remote server. This can be useful when executing commands that do not require interaction or terminal emulation. ssh student@172.16.82.106 -NT
    -C = Enables compression of data during transmission over the SSH connection, reducing bandwidth usage, especially over slow or high-latency connections. ssh student@172.16.82.106 -C
    -J user@host = Specifies a jump host to connect through when establishing the SSH connection. This simplifies the process of connecting to a remote host that is not directly accessible from the local machine. ssh -J student@10.10.0.40, student@172.16.1.15, student@172.16.40.10 student@172.16.82.106
    -L [bind_address:]port:host:hostport = Sets up local port forwarding, allowing connections to a local port to be forwarded over the SSH tunnel to a specified host and port on the remote server. This can be useful for accessing services running on a remote server through a secure tunnel. ssh student@172.16.82.106 -L 1234:192.168.1.10:22
    -R [bind_address:]port:host:hostport = Sets up remote port forwarding, allowing connections to a specified port on the remote server to be forwarded over the SSH tunnel to a host and port on the local machine or another remote server. This can be useful for exposing services running on the local machine to the remote server or other remote machines. ssh student@10.10.0.40 -L 1234:172.16.40.10:22
    -D {port} = Specifies a local "dynamic" port forwarding port. This creates a SOCKS proxy on the specified port, allowing other applications to tunnel their traffic through the SSH connection securely. ssh student@172.16.1.15 -D 9050

Key Generator: Creates user keys and host keys via ssh-keygen
Known-hosts database: Collection of host keys that the client and server refer to for mutual authentication.
Agent: Stores keys in memory as a convenience for users to not input pass-phrases repetitively.Signer: This is a program that signs the hostbased authentication packets.

    SSH-TRAN
    This can be thought of as the building block that provides initial connection, server authentication, basic encryption, integrity services, and compression if needed. SSH-TRANS, or the SSH Transport Layer Protocol, is responsible for establishing a secure, encrypted channel between the SSH client and server. Once this is established, a client has a secure full duplex stream to an authenticated remote peer.
        Connection Establishment:
            Three-way handshake occurs when the client requests a connection establishment to the server’s TCP port 22 by default. Another port can be specified with the use of the (-p port) option.
            Client and server exchanges their SSH protocol versions to ensure compatibility.
        Key Exchange (KEX):
            Client and Server exchange their public keys (User and Host respectively).
        Integrity Protection:
            SSH-TRANS employs integrity-checking mechanisms such as HMAC (Hash-based Message Authentication Code) to verify data integrity and detect any tampering during transmission.
        Encryption:
            SSH client and server agree on a key exchange algorithm (such as Diffie-Hellman, ECDH, or others) to securely negotiate a shared secret.
        Server Authentication:
            SSH-TRANS includes mechanisms for server authentication, where the server presents its digital certificate to prove its identity to the client, preventing man-in-the-middle attacks.
    SSH-USERAUT
    This component is sent over the SSH-TRANS connection and used to authenticate with the client with the server. During this stage the client learns about format of authentication requests, conditions, and available methods of authentication. SSH uses algorithms in compliance with DSS defined in FIPS PUB 186-4. (RSA, DSA, etc.) Most commonly this will be RSA.
        Authentication Methods:
            SSH-USERAUTH supports various authentication methods, including:
                Password authentication
                Public-key cryptography (RSA, DSA, ECDSA) ( -i ~/.ssh/id_rsa)
            Keyboard-interactive authentication (e.g., challenge-response mechanisms)
            Certificate-based authentication (X.509)
        Authorization:
            Once authenticated, SSH-USERAUTH handles authorization checks to determine the level of access and privileges granted to the authenticated user on the server.
    SSH-CONNEC
    SSH-CONNECT, or the SSH Connection Protocol, manages the interactive sessions and secure shell access between the SSH client and server. This component provides the exciting things over a single pipe that is provided by SSH-TRANS. It includes support for multiple interactive and non-interactive sessions. It multiplexes several channels through the underlying connections to allow for TCP, X, and agent forwarding, terminal handling, remote program execution.
        Shell Access:
            Interactive shell sessions (command-line access) where users can execute commands and interact with the remote server’s operating system.
            Non-interactive SSH sessions are commonly used in automated scripts or batch jobs where commands or operations need to be executed on a remote system without manual intervention.
        Secure File Transfer:
            Secure file transfer operations using protocols like SCP (Secure Copy Protocol) or SFTP (Secure File Transfer Protocol), which runs over the SSH connection.
        Port Forwarding:
            SSH tunneling (port forwarding), allowing clients to securely tunnel other network protocols (e.g., HTTP, database connections) over the SSH connection.
                (-L) Local Port Forward
                (-R) Remote Port Forward
                (-D) Dynamic Tunnel (SOCKS Proxy)
        Session Management:
            SSH-CONNECT manages the lifecycle of SSH sessions, including session setup, maintenance, and termination, ensuring efficient and secure communication between the client and server.
        X11 Forwarding (-X):
            Negotiate the capability to forward X11 (graphical) applications from the server to the client securely over the SSH connection.
        Terminal Settings:
            Terminal Type and Size: Specify the terminal type (e.g., xterm, vt100) and size (rows and columns) for the SSH session.
        Logging and Debugging (-v, -vv, -vvv):
            Logging Levels: Determine the level of logging and debugging information to be captured during the SSH session for troubleshooting purposes.
        Compression (-C):
            Compression Algorithms: Specify whether data compression will be used to reduce bandwidth usage during the SSH session (e.g., zlib compression).
        Connection Settings:
            Session Multiplexing: Decide whether multiple logical SSH sessions can share a single underlying network connection (improving efficiency).
            Window and Buffer Sizes: Negotiate the size of data windows and buffers used for transmitting data between the client and server.
______________________________________________________________________________________________________________________
 Analyze Hypertext Transfer Protocol (Secure) (HTTP(s))
HTTP(S) (TCP 80/443)
    The Hypertext Transfer Protocol (HTTP) is an application layer protocol used for communication between web browsers and web servers.
        It serves as the foundation for data communication on the World Wide Web, enabling the retrieval and display of web pages, images, videos, and other resources.
    Key characteristics and features of HTTP include:
        Client-Server Architecture: HTTP follows a client-server model, where the client (usually a web browser) sends requests to the server, and the server responds with the requested data or performs the requested actions
        Stateless Protocol: HTTP is stateless, meaning each request from the client to the server is independent and does not retain any information about previous requests.
        Request-Response Paradigm: Communication in HTTP is basedon a request-response paradigm. The client sends an HTTP request to the server, specifying the desired action (such as retrieving a web page or submitting a form). 
The server processes the request and sends an HTTP response back to the client, containing the requested data or an appropriate status code.
            Request Methods - performed by the client to a server.
                GET - Most common method used. Used to retrieve data from a server.
                POST - Used to send data to the API server. Generally used with storing a file or form.
                PUT - Similar to POST. Used to send data to the API to update or create a resource. It differs from POST in that it is used only on a particular resource.
                PATCH - used to apply partial modifications to the resource.
                DELETE - used to delete the resource at the specified URL.
                HEAD - Similar to GET except it does not return the message body.
                OPTIONS - used to return data describing what other methods and operations the server supports at the given URL.
HTTP server status Codes - server response to a request method.
    1xx - Informational
    2xx - Successful
    3xx - Redirection
    4xx - Client error
    5xx - Server error
______________________________________________________________________________________________________________________
Analyze Domain Name System (DNS) protocol
DNS (QUERY/RESPONSE) (TCP/UDP 53)
    Used as a means to resolve domain names to an IP addresses usable by the client system. Typically used to resolve IP addresses of web domains.
    Client queries and server responses are typically sent using UDP port 53.
    DNS responses over UDP are generally limited to 512 bytes. This limit is due to the constraints of the original DNS protocol specification and the size of a UDP packet. 
        If the response data exceeds this limit, DNS switches to TCP to handle the query.
    TCP is used when DNS responses are larger than 512-bytes.
        DNS Zone transfers are typically over 512-bytes so TCP is used for the transmission.
        Zone transfers are used to replicate DNS databases between DNS servers. These transfers can involve a large amount of data, especially for zones with many records.
        DNS zone transfers are conducted using TCP because they typically involve transferring large amounts of data.

Types Of DNS Records
Type A
    IPv4 Address record, used to map hostnames to an IP address of the host.
Type AAAA
    IPv6 address record, used to map hostnames to an IPv6 address of the host.
Type MX
    Mail exchange record, Maps a domain name to a list of message transfer agents for that domain.
Type TXT
    Text record, human-readable text in a DNS record, but can also store machine-readable data. Often used for verification and authentication.
Type NS
    Name Server record, specifies the authoritative name servers for a domain.
Type SOA
    Start of authority, provides authoritative information about the zone, including administrative details and zone-level settings.
Type AXFR
    AXFR (Full Zone Transfer) facilitates the transfer of the entire DNS zone data, including all resource records, from one DNS server (the master) to another DNS server (the slave).
Type IXFR
    IXFR (Incremental Zone Transfer) Retrieves only the changes made since the last transfer.
Type CNAME
    Canonical Name creates an alias for a domain name, pointing it to another canonical domain.
Type PTR
    Used for reverse DNS lookups to map an IP address to a domain name.
____________________________________________________________________________________________________________________________________________________________________________________________________________________________________________
Analyze File Transfer Protocol (FTP)

FTP (TCP 20/21)
File Transfer Protocol is a standard network protocol that is used for file transfer between a client and a server.
Authentication is performed via a username and password, but can also be disabled in favor of anonymous mode if the FTP server is configured for it. 
The drawback with FTP is that all communication is clear text, including the initial authentication.
FTP has two moes of operation, Active and Passive.
______________________________________________________________________________________________________________________
1 FTP Active
    Active
  A client initiates a connection with a server on port 21 from the client’s ephemeral high port. 
    The three way handshake is completed and the client listens on its ephemeral high port + 1, the client sends the port N+1 command to the server on port 21 (control port). 
Ex: if the command to the server is from ephemeral port 1026, it would listen on port 1027.
    Once that is done, the server initiates a connection to the client’s ephemeral high (1027) from the server’s data port (20) and the data is transferred.
"WALKTHROUGH"
    The client’s command port contacts the server’s command port and sends a command for the client’s ephemeral high port + 1
    The FTP server responds to the client with an ACK to the client’s command port
    The FTP server initiates a connection from its data port 21 to the client’s specified data port (ephemeral high + 1)
    The FTP client sends an ACK back to the server’s data port 20 from the client’s ephemeral high data port. This also leads to issues when using ftp through an SSH tunnel which will be discussed later.
______________________________________________________________________________________________________________________
 FTP Passive
    Passive
    Passive FTP sidesteps the issue of Active mode by reversing the conversation. The client initiates both the command and data connections.
"WALKTHROUGH"
    The client’s command port (1029) contacts the server’s command port (20) and sends the PASV command.
    The FTP server responds to the client with an ACK to the client’s ephemeral high command port (1029) letting the client know the server’s listening data port (2020).
    The FTP client initiates the data connection from its ephemeral high port (1030) to the FTP server’s listening data port (2020)
    The FTP server sends an ACK back to the client’s ephemeral high data port (1030)
____________________________________________________________________________________________________________________________________________________________________________________________________________________________________________
Analyze Trivial File Transfer Protocol (TFTP)
TFTP (UDP 69)
    Trivial File Transfer Protocol (TFTP) is a simple File Transfer Protocol which allows a client to get/put a file from/to a remote host. 
        One of its primary uses is in the early stages of nodes booting from a local area network.
    TFTP has been popular due to its simple easy of implementation.
    IT pros and Sys Admins typically use TFTP configuration for:
        Transferring files
        Remote-booting without hard drives
        Upgrading codes
        Backing up network configurations
        Backing up router configuration files
        Saving IOS images
        Booting PCs without a disk
______________________________________________________________________________________________________________________
Analyze Simple Mail Transfer Protocol (SMTP)
SMTP (TCP 25)
Simple Mail Transfer Protocol (SMTP) is an internet standard used for sending electronic mail. SMTP is not encrypted and will require other methods to secure the data.
______________________________________________________________________________________________________________________
 Analyze  Post Office Protocol (POP)
POP (TCP 110)
Post Office Protocol (POP) is an older internet standard used to retrieve electronic mail from a server. Most implementations of POP will delete the server stored mail once the client downloads them. 
This meant that the client can only read the email from the system that was used to download them. The latest version is POP3.
______________________________________________________________________________________________________________________
Analyze Internet Message Access Protocol (IMAP) - no encryption
IMAP (TCP 143)
Similar to POP in that it is used to download electronic mail from a server.
It differs from POP in that it typically synchronizes with the server so that the client can download the mail but have it still stored on the server.
This allowed clients to retrieve their emails from multiple systems. The current implementation is IMAP4.
______________________________________________________________________________________________________________________
DHCP (UDP 67/68)
Dynamic Host Configuration Protocol (DHCP) is an internet standard used to assign IP address parameters across an enterprise. 
    This prevent administrators from having to manually assign IP configuration on each host individually. Clients communicate with the server over UDP port 67 and the server communicates with the client over UDP port 68.
    IPv4 DHCP process (D.O.R.A)
        Discover - Sent as a L2 and L3 broadcast by the client to discover a DHCP server. Broadcast can only reach devices on the same network. 
            If the DHCP server is not on the local network then the router must use the ip helper command to relay these requests to a centralized DHCP server.
        Offer - Sent as a unicast to the client. The offer will contain the offered IP address configurations.
        Request - Sent as a broadcast back to the server. This is broadcasted because the client could have received 2 or more offers. 
            The broadcast will announce to all DHCP servers as to which offer was accepted. The client will send a gratuitous ARP to attempt to determine if the IP address is already in use.
        Acknowledge - Final response from the server sent as a unicast to the client to confirm the lease reservation. Will contain the expiration timeframe of the lease.
   
IPv6 DHCP process - Similar to the process of DHCPv4 except the names and communication methods differ.
        Solicit - Sent to the server as a multicast.
        Advertise - Unicast response from server.
        Request - Multicast to the server.
        Reply - Unicast server response.
______________________________________________________________________________________________________________________
Analyze Network Time Protocol (NTP) 
NTP (UDP 123)
The Network Time Protocol (NTP) is a networking protocol for clock synchronization between computer systems over packet-switched, variable-latency data networks. 
  NTP is intended to synchronize all participating computers to within a few milliseconds of Coordinated Universal Time (UTC).
    Uses stratum levels to determine the distance from the "authoritative" time source.
        Stratum 0 - Identifies the device as the "authoritative" time source.
        Stratum 1 - Syncs their time from Stratum 0.
        Stratum 2 - Syncs their time from Stratum 1.
        Stratum 3 to 15 - Follows same scheme as above. Stratum 15 is the highest level.
        Stratum 16 - Signifies that the device is unsynchronized.
______________________________________________________________________________________________________________________
Analyze Terminal Access Controller Access-Control System Plus (TACACS+) Protocol
TACACS (TCP 49) SIMPLE/EXTENDEDThe Terminal Access Controller Access-Control System Plus (TACACS+) is a network security protocol used for centralized authentication,
authorization, and accounting (AAA) services in network devices such as routers, switches, and firewalls. Developed by Cisco Systems, TACACS+ provides a robust framework for controlling access to
network resources and enforcing security policies.
Analyze Remote Authentication Dial-In User Service (RADIUS) protocol
______________________________________________________________________________________________________________________
RADIUS (UDP 1645/1646 AND 1812/1813)
Remote Authentication Dial-In User Service (RADIUS) is a open standard networking protocol used for centralized authentication, authorization, and accounting (AAA) services in network environments.
It enables devices like network access servers (NAS), VPN gateways, and wireless access points to authenticate users and authorize their access to network resources.
______________________________________________________________________________________________________________________
Analyze Diameter Protocol
DIAMETER (TCP 3868)
Diameter is a networking protocol used for Authentication, Authorization, and Accounting (AAA) functions in network systems, primarily in telecommunications networks.
 It is an evolution of the older RADIUS (Remote Authentication Dial-In User Service) protocol, providing enhanced features and capabilities.
Diameter protocol was develop to enhance the AAA capablities that RADIUS does not support. Such as:
    Supports application-layer acknowledgments and defines failover algorithms and the associated state machine.
    Transmission-level security support via TLS/TCP and DTLS/SCTP. Diameter can work over TCP, Stream Control Transmission Protocol (SCTP), or UDP. SCTP is recommended.
    Diameter includes support for error handling, capability negotiation, and mandatory/non-mandatory Attribute-Value Pairs (AVPs).
Header information:
    Version - field MUST be set to 1 to indicate Diameter Version 1.
    Message Length - indicates the length message including the header fields and the padded AVPs. Message Length field is always a multiple of 4.
    Command Flags - R(equest), P(roxiable), E(rror), T(Potentially retransmitted message), or r(eserved).
    Command Code - used in order to communicate the command associated with the message.
    Application ID - enables the base protocol stack to route the message to the Accounting, Authentication, or the other Diameter applications.
    Hop-by-Hop Identifier - correlates the information with the peer (next-hop or neighbor) entity.
    End-to-End Identifier - correlates the information with the endpoint for the transaction, which may be several hops away.
    AVPs - are a method of encapsulating information relevant to the Diameter message.
______________________________________________________________________________________________________________________
Analyze Simple Network Management Protocol (SNMP)
SNMP (UDP 161/162)
Simple Network Management Protocol (SNMP) is an Internet Standard protocol for collecting and organizing information about managed devices on IP networks. Devices that typically support SNMP include cable modems,
    routers, switches, servers, workstations, printers, and more.
    3 Key SNMP Components
        SNMP Manager - It is a centralized system used to monitor the network. It is also known as Network Management Station (NMS)
        SNMP agent - It is a software management software module installed on a managed device. Managed devices can be network devices like PC, router, switches, servers, etc.
        Management Information Base - MIB consists of information on resources that are to be managed. This information is organized hierarchically. It consists of objects instances which are essentially variables.
    SNMP Versions
        SNMPv1 – This was the first implementation, operating within the structure management information specification, and described in RFC 1157. It uses community strings for authentication and UDP only.
        SNMPv2c – This version has improved support for efficiency and error handling and is described in RFC 1901. It was first introduced in RFC 1441 and is more appropriately known as SNMP v2c. 
            It uses community strings for authentication. It uses UDP but can be configured to use TCP.
        SNMPv3 – This version improves security and privacy. It was introduced in RFC 3410. It uses Hash-based MAC with MD5 or SHA for authentication and DES-56 for privacy. This version uses TCP.
            Therefore, the higher the version of SNMP, the more secure it will be.
            noAuthNoPriv – This (no authentication, no privacy) security level uses community string for authentication and no encryption for privacy.
            authNopriv – This security level (authentication, no privacy) uses HMAC with MD5 or SHA for authentication and no encryption is used for privacy.
            authPriv – This security level (authentication, privacy) uses HMAC with MD5 or SHA for authentication and encryption uses DES-56(56-bit) algorithm, 3DES(168-bit), AES(128/192/256-bit).

______________________________________________________________________________________________________________________
Analyze Real-time Transport Protocol (RTP)
RTP (UDP any above 1023)
RTP (Real-time Transport Protocol) is primarily used for streaming real-time media over IP networks.
    It is a protocol specifically designed for transmitting audio and video data in a way that supports time-sensitive applications, such as voice and video communication, streaming media, and live broadcasts.
    Voice over IP (VoIP): RTP is widely used in VoIP applications to transport real-time voice data packets over IP networks.
It works in conjunction with protocols like SIP (Session Initiation Protocol) to enable voice communication over the internet.
    Video Conferencing: RTP forms the basis of video conferencing systems, allowing participants to transmit and receive real-time video streams during live meetings or conferences.
    Streaming Media: RTP is commonly used for streaming media services, such as online video streaming platforms, live broadcasts, and webinars. 
        It facilitates the efficient transmission of video and audio data to multiple clients in real-time.
    IPTV (Internet Protocol Television): RTP is used in IPTV systems to deliver television content over IP networks, enabling users to stream television programs and video-on-demand services over the internet.
Multimedia Applications: RTP is utilized in various multimedia applications, including gaming, remote monitoring, video surveillance, and interactive multimedia services.
        It provides a reliable and efficient transport mechanism for transmitting time-sensitive media data.
Real-time Data Transmission: RTP can be used for real-time data transmission scenarios where timely delivery is crucial. For example, it may be employed in sensor networks, control systems,
        or any application that requires the transmission of real-time data streams.
______________________________________________________________________________________________________________________
Analyze Remote Desktop Protocol (RDP)
RDP (TCP 3389)
Developed by Microsoft to offer remote access to a computer’s desktop GUI as if they was physically at the system rather than just a command-line interface.
The protocol is widely supported across most Windows, Unix, Linux, and macOS operating systems. Other proprietary options were developed to provide remote desktop support but
    the administrator typically must install the client software on each device before being able to remotely access devices with these 3rd party tools.
______________________________________________________________________________________________________________________
 Analyze Kerberos
Kerberos (UDP 88)
Kerberos is a network authentication protocol that ensures secure authentication for client-server applications. It was created by MIT as a network authentication protocol using secret-key cryptography. It relies on a trusted Key Distribution Center (KDC) server.
Here’s a simplified explanation of the Kerberos process:
    Authentication Request:
        The client sends an authentication request to the KDC, providing its identity (username) and the desired server’s identity (service principal name).
    Ticket Granting Ticket (TGT) Request:
        The KDC verifies the client’s identity and issues a TGT if the credentials are valid.
        The TGT is encrypted using the client’s password or a shared secret key.
    TGT Issuance:
        The KDC sends the encrypted TGT to the client, which stores it securely.
    Service Ticket Request:
        When the client wants to access a specific service, it requests a Service Ticket (ST) for that service from the KDC.
        The request includes the TGT and the desired service’s identity.
    ST Issuance:
        The KDC verifies the TGT and issues an ST for the requested service if the TGT is valid.
        The ST is encrypted using a session key shared between the client and the service.
    Service Access:
        The client presents the ST to the service, proving its authenticity and intent to access the service.
        The service decrypts the ST using the session key and verifies its validity.
        If the ST is valid, the service grants access to the client.
Kerberos utilizes symmetric key cryptography for secure ticket encryption and decryption, ensuring data confidentiality and integrity. It also supports mutual authentication between the client and server.
    Kerberos is widely used in enterprise environments, particularly in Microsoft Windows with Active Directory.
        It ensures secure authentication and access to network resources while protecting against unauthorized access and replay attacks.
______________________________________________________________________________________________________________________
Analyze Lightweight Directory Access Protocol (LDAP)
LDAP (TCP 389 and 636)
The Lightweight Directory Access Protocol (LDAP) is an application protocol used for accessing and managing distributed directory information services. 
LDAP provides a standardized method for querying, modifying, and authenticating against directory services, such as Active Directory and OpenLDAP.
LDAPS (LDAP over SSL/TLS) is a secure communication protocol used to encrypt LDAP traffic between LDAP clients and servers.
    It provides a layer of security to LDAP authentication and directory access by encrypting data exchanged over the network, protecting it from eavesdropping and tampering.
    LDAP provides access to distributed directory services that act in accordance with X.500 data and service models. These protocol elements are based on those described in the X.500 Directory Access Protocol (DAP).
    LDAP as an authentication service follows the client/server model. The LDAP model has two main steps when a user requests non-TLS bind authentication. These are (in order):
        TCP three-way handshake (SYN, SYN/ACK, ACK)
        LDAP bind() function (performed synchronous or asynchronous)
LDAP:
    LDAP (unencrypted): TCP Port 389
    LDAPS (LDAP over SSL/TLS): TCP Port 636
    follows a client-server model, where LDAP clients send requests to directory servers, which in turn provide responses.
    hierarchical data stores that organize and store structured information, such as user profiles, organizational units, and network resources.
    uses a directory schema to define the structure and attributes of directory entries, allowing for flexible data modeling.
    supports various operations, including search, add, modify, delete, and bind (authentication).
    uses a string-based query language called the LDAP Data Interchange Format (LDIF) to search and retrieve data from directory servers.

    LDAP Directory Structure - Directory Information Tree (DIT):
        The DIT is a hierarchical structure that organizes entries based on their distinguished names (DNs). The hierarchy is similar to a file system directory tree and is composed of:
            Entries: Each entry represents an object in the directory, such as a user, group, or organization.
                Root: The top-level of the hierarchy. The root entry is the starting point of the directory tree.
                    Example: The root DN might be something like dc=example,dc=com, representing the top-level domain for the directory

                Base DN: The starting point for searches within the directory. It represents a specific part of the hierarchy from which you want to begin your search.
                    Example: ou=Users,dc=example,dc=com might be used as the base DN for searching user entries.
                Organizational Units (OUs): Containers within the directory used to organize entries into logical groups, such as departments or roles.
                    Example: ou=Sales,dc=example,dc=com and ou=IT,dc=example,dc=com.
                Entries: Individual objects in the directory, each identified by a unique DN. Entries can represent users, groups, devices, etc.
                    Example: uid=johndoe,ou=Users,dc=example,dc=com represents a user entry for John Doe.
        Attributes: Each entry contains a set of attributes, which are key-value pairs representing information about the entry.
            Attribute Syntaxes: LDAP attributes have associated syntaxes, which define the data type and format of the attribute’s values. Common syntaxes include:
                String: Textual data
                Integer: Integer values
                Boolean: True or false values
                DN: Distinguished Name (reference to another entry)
                GeneralizedTime: Date and time
            User Attributes
                uid: Unique identifier for the user (often the username)
                cn: Common name (usually the full name)
                sn: Surname
                givenName: Given name
                mail: Email address
                telephoneNumber: Phone number
                description: Additional information about the user
                userPassword: Password (though storing passwords in plain text is highly discouraged)
                memberOf: Groups the user belongs to
            Group Attribute

                cn: Common name of the grou
                description: Description of the group
                member: List of members (usually user DNs)
            Computer Attributes
                cn: Common name of the computer
                description: Description of the computer
                operatingSystem: Operating system
                ipaddress: IP address
______________________________________________________________________________________________________________________
Day 3
Traffic Capture
NPcap(windows)
libPcap(linux)

Practical uses:
    Network Troubleshooting
    diagnosing improper routing or switching
    identifying port/protocol misconfigurations
    monitor networking consumption
    intercepting users and passwords
    Eavesdrop on network comms

Disadvantages:
    requires elevated permissions
    can only capture what NIC can see
    cannot capture local traffic
    can consume massive amounts of system resources
    lost packets on busy networks

Two Ways Packets can be Captured
    Hardware Packet Sniffers - In the past, the process of traffic sniffing was typically done by using hardware devices because the act of capturing packets was too intensive for computers.
        It is a purpose-built device that is plugged into a network segment to collect and store network packets. Packets are forwarded to a separate system for further analysis.
        With the improvement of computer CPUs, stand-alone hardware-based sniffers are rarely used anymore.
    Software Packet Sniffers - remaining packet sniffers will fall into this category. The local system is used to collect the packets and the software then provides immediate analysis. Software-based sniffers rely on the network interface card (NIC) in the host system to pass traffic to the OS.
        NICs are set into one of two modes:
         Non-promiscuous: Default for most NICs. NIC will only process traffic destined for its host MAC address. Multicast MAC address groups and broadcast addresses are also received and processed.
         Promiscuous: Requires root/kernel permissions to enable. The NIC receives and processes all traffic. Most operating systems can support promiscuous mode. Support can be limited by the NIC hardware and/or drivers.


Socket Types
    User Space Sockets
        Stream Socket - TCP - Normally used with TCP, SCTP, and Bluetooth. 
                                A stream socket provides a connection-oriented and sequenced flow of data which has methods for establishment and teardown of connections as well as error detection.
        Datagram Socket - UDP -Normally used with UDP. A datagram socket is connection-less by nature. Sockets built this way can send and receive data,
                                but there is no mechanism to retransmit data if a packet is dropped.
    Kernal Space Sockets
        RAW Sockets - A raw socket allows for the direct sending and receiving of IP packets without automatic protocol-specific transport layer formatting,
                        meaning that all headers are typically included in the packet and not removed when moving up the network stack.

Types of Sniffing   
    Active sniffing – Traffic is not only captured but can be manipulated or altered in some way for a network attack.
        Passive sniffing involves monitoring network traffic without actively injecting or modifying packets.
        It typically uses network monitoring tools or packet capture software to capture packets as they traverse the network.
        Passive sniffing is often used for network troubleshooting, security monitoring, and performance analysis.
            Some examples of attacks that employ Active sniffing are:
                MAC Flooding
                DHCP Attacks
                DNS Poisoning
                Spoofing Attacks
                ARP Poisoning
    Passive sniffing – Traffic is captured and not modified. This is the most common method of packet sniffing.
            Active sniffing involves actively injecting packets into the network to elicit responses from other devices.
            Unlike passive sniffing, active sniffing requires the sniffer to send packets to specific destinations and analyze the responses. 
            Active sniffing can be more intrusive and may raise security concerns, but it can also provide more detailed insights into network behavior.
            Several applications that send data in clear text are vulnerable to this type of sniffing:
                HTTP
                SMTP
                NNTP
                FTP
                POP
                IMAP
                TELNET
                DNS

Interface Naming
    Traditional
        eth0, eth1
        ethX: Ethernet devices are typically named ethX, where X is a number. For example, eth0, eth1, etc.
        wlanX: Wireless LAN devices are named wlanX, where X is a number.
        pppX: Point-to-Point Protocol devices are named pppX, where X is a number.
        tunX or tapX: TUN/TAP devices are named tunX or tapX, where X is a number.

    Consistent
        eno1, ens3
        en = Ethernet
        ib = InfiniBand
        sl = Serial line IP (slip)
        wl = Wireless local area network (WLAN)
        ww = Wireless wide area network (WWAN)

TCPDUMP 
TCPDUMP breaks down its filters into three (3) different capture qualifiers:
    type - specifies the 'ind of thing' that the id name or number refers to.
        Possible types are:
        host
        net
        port
        portrange
        Examples: `host 192.168.1.1', `net 192.168.1.0/24', `port 22', `portrange 1-1023'. If there is no type qualifier, host is assumed.
    dir - specifies a particular transfer direction to and/or from id.
        Possible directions are:
        sr

        dst
        src or dst
        src and dst
        ra
        ta
        addr1, addr2, addr3, and addr4.
        Examples: `src 192.168.1.1', `dst net 192.168.1.0/24', `src or dst port ftp-data'. If there is no dir qualifier, `src or dst' is assumed.
                The ra, ta, addr1, addr2, addr3, and addr4 qualifiers are only valid for IEEE 802.11 Wireless LAN link layers.
    proto - restricts the match to a particular protocol(s).
        Possible protos are: ether, fddi, tr, wlan, ip, ip6, icmp, icmp6, arp, rarp, decnet, tcp and udp.
        Examples:
        `ether src 192.168.1.1'
        `arp net 192.168.1.0/24'
        `tcp port 22'
        `udp portrange 1-1023'
        `wlan addr2 0:2:3:4:5:6'

-A  print payload in ASCII
-D  List interfaces
-i  specify capture interface
-e  print data-link headers
-X pr XX  print payload in HEX or ASCII
-w  write to pcap (save)
-r  reads from pcap (open)
-v  gives more verbose output
-n  no inverse lookups

Logical Operators for TCPDUMP
        Concatenation: 'and' (&&) - Returns true if both operands are true.
        Alteration: 'or' (||) - Returns true if at least one operand is true.
        Negation: 'not' (!) - Reverses the logical state of its operand (true becomes false, and vice versa).
            <        less than
            < =      less than or equal to
            >        greater than
            >=       greater than or equal to
            = (==)   equal to
            !=	     not equal to

    Primitives(macros) 
        CMU/Stanford Packet Filter (CSPF) Model commonly called Boolean Expression Tree
        Simple and easy filter expressions
        First user-level packet filter model
        Memory-stack-based filter machine which can create bottlenecks on model CPUs
        can have redundant computations of the same information
    Berkley Packet Filters (BPF)
        Control Flow Graph (CFG) Model
        Uses a simple (non-shared) buffer model which can make it 1.5 to 20 times faster than CSPF
        Can be more complex to create expressions but offer far more precision

Berkley Packet Filter(BPF)
BPF’s in conjunction with TCPDump, operators, and bitmasking make for an extremely powerful traffic filtering and parsing tool.
    The smallest filter that BPF can understand easily is a byte.
    A span of bytes can be denoted as in the BPF Bytecode example "ether[12:2]", starts at byte offset 12 and span 2 bytes in to look at the ethertype field.
    Using BPFs with operators, bitmasking, and TCPDump creates a powerful tool for traffic filtering and parsing.
    > tcpdump {A} [B:C] {D} {E} {F} {G}
    A = Protocol ( ether | arp | ip | ip6 | icmp | tcp | udp )
    B = Header Byte number
    C = optional: Byte Length. Can be 1, 2 or 4 (default 1)
    D = optional: Bitwise mask (&)
    E = Relational operator ( = | == | > | < | <= | >= | != | () | << | >> )
    F = Result of Expression
    G = optional: Logical Operator (&& ||) to bridge expressions

EXAMPLE:
tcpdump 'ether[12:2] = 0x0800 && (tcp[2:2] != 22 && tcp[2:2] != 23)'
This expression with look for any IPv4 traffic that is not SSH or Telnet.
    First it will look at ether[12:2] which is typically the ethertype field. The expression tells the system to check if this field contains 0x0800.
    Conjoins the first expression with the &&.
    Using the () and || operators we can build two or more expressions to look for. In this case it checks the TCP destination field (tcp[2:2]) does not contain 22 or 23.

Bitwise Masking
    BPF can read 1(byes), 2 (half-word), 4(word)
When using Berkeley Packet Filters, we have the ability to specify capture filters with greater precision by using bit-wise masking. This enables us to specify filters down to the bit-level. 
    After we specify the byte(s) to be examined, we would then need to apply a mask to specify which bits are significant (1) and which bits are insignificant (0).
    In this image we are applying a bitwise mask to byte [0] of the IP header. This byte contains both the Version and Internet Header Length (IHL) fields with each being 4-bits or 1 nibble.
    We know that all ipv4 traffic will contain a value of 4 (0x4) in the high nibble to signify the version.
The IHL field is normally 5 to signify that the IP header is 5 WORDS (32-bits) in length. We can apply a filter to focus on only the IHL field and print any packets that this field is greater than 5.
    https://net.cybbh.io/public/networking/latest/06_traffic_cap/_images/ver-ihl-bpf.png
ip[0] & 0x0F > 0x05

 In this image we are applying a bitwise mask on the Fragmentation offset field in the IP header. This field consumes the lower 6-bits of byte [6] and the entirety of byte [7].
    So to examine this field, we will need to read both bytes [6] and [7] but ignore the first 3-bits in byte [6].
    https://net.cybbh.io/public/networking/latest/06_traffic_cap/_images/BPF_Mask2.png
    ip[6:2] & 0x1fff > 0x0000

TCP byte offset 13
    -TCP flags 
    - 0x11 ack/fin
 tcpdump 'tcp[13] & 0x11 = 0x11' means that the flag is on in those positions

TCP byte offset 12
    -Offset and Reserved
    tcpdump 'tcp[12] & 0xf0 > 0x50'
        
searching for ttl using ipv4
    -tcpdump -i eth0 'ip[8] = 128'

'tcp[0:2] = 3389'
    -source

'tcp[2:2] = 3389'
    -destination
___________________________________________________________________________________________________________
___________________________________________________________________________________________________________
                        WIRESHARK
    Wireshark Display Filters vs Capture filters
Display filters - allow you to change the view of what packets are displayed of those that are captured. Wireshark has specific display filters that it uses and 
    it does not conform to TCPDUMP primitives or BPF format. 
    If you start a Wireshark Packet capture without specifying any capture filters then Wireshark will capture all packets it can regardless if the information is useful or not. 
    ON busy networks you can quickly accumulate packets and all are saved to disk.
    It is entirely feasible to fill your entire hard drive very quickly causing your computer to freeze and crash if not carefully monitored.

Capture filters - used to specify which packets should be saved to disk while capturing.
    By default, there are no capture filters applied so all packets will be captured if nothing is specified. TCPDUMP primitives and/or BPFs can be applied and conjoined to make capture filters



Wireshark display filters are a powerful feature that allows users to selectively view network traffic based on specific criteria. 
These filters enable users to focus on particular packets of interest while disregarding others,making it easier to analyze network communication and identify relevant information.
Here is a list of common and popular Wireshark Display filters.
    Filtering for a particular protocol will give all packets that have the protocol header in the packet payload.
        This will NOT show the TCP setup, TCP teardown, or fragmented packets that are part of the communication but do not have the protocol header in payload.
        We can filter for specific protocols such as:
            Layer 2: eth, arp, vlan, wlan
            Layer 3: ip, ipv6, icmp, icmpv6
            Layer 4: tcp, udp
            Layer 5: smb, socks, rpc
            Layer 7: telnet, ssh, http, ssl, tls, quic, dns, ftp, ftp-data, tftp, smtp, pop, imap, dhcp or bootp, ntp, tacplus, radius, rdp
            Routing protocols: rip, ospf, bgp
    We can filter for specific addresses:
        Layer 2: eth.addr, eth.dst ==, eth.src ==
        Layer 3: ip.addr ==, ip.dst ==, ip.src =
        Layer 4: tcp.port ==, tcp.dstport ==, tcp.srcport ==, udp.port ==, udp.dstport ==, udp.srcport ==
    IPv4 Filters
        IHL: ip.hdr_len == 20, ip.hdr_len > 
        DSCP: ip.dsfield.dscp > 0, ip.dsfield.dscp == 48
        ECN: ip.dsfield.ecn > 0. ip.dsfield.ecn == 2
        Flags: ip.flags.rb == 1, ip.flags.df == 1
        Fragmentation: (ip.flags.mf == 1) || (ip.frag_offset > 0)
        TTL: ip.ttl == 64, ip.ttl == 128, ip.ttl ⇐ 64 && ip.ttl > 30 && !(ip.ttl > 64)
        Protocol: ip.proto == 1, ip.proto == 6, ip.proto == 17
        6-in-4 or 6-to-4 encapsulation: ip.proto == 41
    IPv6 Filters:
        Traffic Class: ipv6.tclass > 0, ipv6.tclass == 0xe0
        Next Header: ipv6.nxt == 6, ipv6.nxt == 17, ipv6.nxt == 58
        4-in-6 encapsulation: ipv6.nxt == 4
    TCP Specific Filters:
        TCP Offset: tcp.hdr_len == 32, tcp.hdr_len > 20
        TCP Flags:
            Individual Flags: tcp.flags.syn == 1, tcp.flags.ack == 0, tcp.flags.urg == 1. tcp.flags.reset == 1
            Flag Combinations: tcp.flags == 0x002, tcp.flags == 0x012, tcp.flags == 0x010, tcp.flags == 0x018
        Urgent Pointer: tp.urgent_pointer > 0
    HTTP specific filters:
        http.request
        http.request.method == <method>
            <method> = GET, POST, HEAD, etc.
        http.response
        http.response.code == <code>
            100, 200, 300, 400, etc.
        http.user_agent, http.user_agent == "Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US; rv:1.8.1.2) Gecko/20070219 Firefox/2.0.0.2", !(http.user_agent == "Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US; rv:1.8.1.2) Gecko/20070219 Firefox/2.0.0.2")
    DNS filters:
        Query: A = dns.qry.type == 1, NS = dns.qry.type == 2, SOA = dns.qry.type == 6, AAAA = dns.qry.type == 28, AXFR = dns.qry.type == 252
        Response: A = dns.resp.type == 1, NS = dns.resp.type == 2, SOA = dns.resp.type == 6, AAAA = dns.resp.type == 28, AXFR = dns.resp.type == 252
    SSH Filters:
        ssh.protocol, ssh.protocol == "SSH-2.0-OpenSSH_7.2p2 Ubuntu-4ubuntu2.1"
    ARP Filters:
        ARP Request/Reply: arp.opcode == 1, arp.opcode == 2
        RARP Request/Reply: arp.opcode == 3, arp.opcode == 4
        Gratutious ARP: (arp.opcode == 2) && (eth.addr == ff:ff:ff:ff:ff:ff)
    ICMP Filters:
        Echo Request: icmp.type == 0
        Echo Reply: icmp.type == 8
        Time Exceeded: icmp.type == 1
        Destination Unreachable and Port Unreachable: (icmp.type == 3) && (icmp.code == 3)
    DHCP Filters:
        Client to Server: (udp.srcport == 68) && (udp.dstport == 67)
        Server to Client: (udp.srcport == 67) && (udp.dstport == 68)
        Discover: dhcp.option.dhcp == 1
        Offer: dhcp.option.dhcp == 
        Request: dhcp.option.dhcp == 3
        Ack: dhcp.option.dhcp == 5
    FTP Filters:
        Commands: ftp.request.command
        Sending username or password: ftp.request.command == "USER", ftp.request.command == "PASS"
        Download file: `ftp.request.command == "RETR"
        Upload file: ftp.request.command == "STOR"
        Switch to passive mode: ftp.request.command == "PASV"
        Directory listing: ftp.request.command == "LIS
    Wildcard string filters:
        data contains "String" - generic filter used to match packets based on the presence of specific data within the packet payload.
        ip contains "String" - specifically targets the IP (Internet Protocol) layer for payload.
        http contains "String" - specifically targets the HTTP (Hypertext Transfer Protocol) payload.
    Using the not feature:
        Generally you can use any filter used above and surround it like this:
        !(filter)
    Conjoining filter expressions:
        both conditions must be true: and or &&
        either the first condition or the second condition is true: or or ||
    Following Protocol Streams:
        In Wireshark, you can follow protocol streams to examine the communication between hosts using various protocols, including TCP, UDP, and others.
        Analyze → Follow →
            TCP Stream (ctrl+alt+shift+T)
            UDP Stream (ctrl+alt+shift+U)
            TLS Stream (ctrl+alt+shift+S)
            HTTP Stream (ctrl+alt+shift+H)
    Apply as filter options:
        In Wireshark, the "Apply as Filter" feature allows you to quickly create display filters based on specific packet attributes or values.
T                his feature is useful for narrowing down the packets displayed in the packet list pane to focus on specific criteria of interest.
            Identify Packet Attribute: Start by identifying the packet attribute or value you want to create a filter for.
                    This could be any field or value present in the captured packets, such as source or destination IP addresses, port numbers, protocols, packet content, or any other packet attribute.
            Select Packet: In the packet list pane of Wireshark, select the packet containing the attribute or value you want to create a filter for.
                This could be any packet in the packet list that contains the desired attribute.
            Right-Click Packet: Right-click on the selected packet to open the context menu.
            Apply as Filter: From the context menu, hover over the "Apply as Filter" option. A submenu will appear displaying different filtering options based on various packet attributes,
                such as IP addresses, protocols, and packet content.
            Analyze → Apply as Filter →
                Selected: This option applies a filter based on the attribute or value of the packet that you currently have selected in the packet list pane. Only packets matching filter is displayed.
                Not Selected: This option applies a filter based on the attribute or value of packets that are not currently selected in the packet list pane. All other packets are displayed except those matching filter.
                …​or Selected: This option combines the attribute or value of the packet that you currently have selected in the packet list pane with the attribute or value of other packets.
                    Packets matching first filter or packets matching additional filters.
                …​and Selected: This option combines the attribute or value of the packet that you currently have selected in the packet list pane with the attribute or value of other packets. 
                Packets matching each filter.
                .. or not Selected: This option applies a filter based on the attribute or value of packets that are not currently selected in the packet list pane, in combination with other attributes or values. Additional or conditional filters to exclude from view.
                …​and not Selected: This option combines the attribute or value of packets that are not currently selected in the packet list pane with the attribute or value of other packets.
                Packets matching each condition is excluded.

Passive OS Fingerprinting (P0F)
Passive OS Finger-printer (p0f) is a tool that allows the passive scanning of network traffic. It is a traffic/packet sniffer like TCPDUMP and Wireshark. 
It makes use of the packet capture libraries like libpcap, winpcap, and NPCAP just as these other traffic sniffers to collect packets.
The only thing that separates p0f from other collectors is how it uses and parses the captured data. Rather than capturing all packets, p0f only examines them and matches them to a signature database. 
This database allows p0f to make a "best guess" on the sending Operating system (OS) and/or application.

Passive OS fingerprinting (p0f) focuses on uniqueness in IP and TCP implementations to discover which OS sent the traffic.
Specifically, p0f looks at header and payload items like initial TTL, fragmentation flag, default packet length of an IP header, Windows size, and TCP options in TCP SYN and SYN/ACK packets. 
The makers of p0f studied this uniqueness and developed a signature database (/etc/p0f/p0f.fp).

p0f -i eth0
p0f -r wget.pcap



































































































































































































